{"files":[{"id":"acfd80a1-49f5-4414-b556-96cc85df8acd","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/Martinique\",\n  \"dependencies\": {\n    \"enabledAdvancedServices\": [\n      {\n        \"userSymbol\": \"Drive\",\n        \"version\": \"v3\",\n        \"serviceId\": \"drive\"\n      },\n      {\n        \"userSymbol\": \"Sheets\",\n        \"version\": \"v4\",\n        \"serviceId\": \"sheets\"\n      },\n      {\n        \"userSymbol\": \"Script\",\n        \"version\": \"v1\",\n        \"serviceId\": \"script\"\n      }\n    ]\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"oauthScopes\": [\n    \"https://www.googleapis.com/auth/script.external_request\",\n    \"https://www.googleapis.com/auth/script.projects.readonly\",\n    \"https://www.googleapis.com/auth/script.deployments.readonly\",\n    \"https://www.googleapis.com/auth/spreadsheets\",\n    \"https://www.googleapis.com/auth/drive\"\n  ],\n  \"webapp\": {\n    \"executeAs\": \"USER_DEPLOYING\",\n    \"access\": \"ANYONE_ANONYMOUS\"\n  }\n}"},{"id":"fde0cb58-c952-4d2b-8f6f-d44d031ed2df","name":"G00_BOOTSTRAP","type":"server_js","source":" // File: /CODE/00_BOOTSTRAP.gs\n\n/**\n * IAPF MEMORY HUB V1 ‚Äî Bootstrap \u0026 Guardrails\n * Bound script: uses SpreadsheetApp.getActiveSpreadsheet()\n * No destructive ops: MEMORY_LOG append-only\n */\n\nconst IAPF \u003d {\n  APP_NAME: \"IAPF Memory Hub V1\",\n  MENU_NAME: \"IAPF Memory\",\n  TZ: Session.getScriptTimeZone(),\n  SETTINGS_SHEET: \"SETTINGS\",\n  MEMORY_LOG_SHEET: \"MEMORY_LOG\",\n  SNAPSHOT_SHEET: \"SNAPSHOT_ACTIVE\",\n  ERRORS_SHEET: \"ERRORS\",\n  LOGS_SHEET: \"LOGS\",\n\n  PROP_PREFIX: \"IAPF_MEMORY_\",\n  PROP_KEYS: {\n    MEMORY_ROOT_FOLDER_ID: \"memory_root_folder_id\",\n    SNAPSHOTS_FOLDER_ID: \"snapshots_folder_id\",\n    LOGS_FOLDER_ID: \"logs_folder_id\",\n    ROADMAP_FILE_ID: \"roadmap_file_id\",\n    SOURCES: \"sources\"\n  },\n\n  // Snapshot params\n  MAX_MEMORY_ITEMS: 30,\n  MAX_LINES_CONTEXT: 20,\n\n  // Secret detection (very conservative)\n  SECRET_PATTERNS: [\n    /sk-[A-Za-z0-9]{10,}/g,\n    /AIza[0-9A-Za-z\\-_]{10,}/g,\n    /-----BEGIN [A-Z ]+ PRIVATE KEY-----/g,\n    /xox[baprs]-[A-Za-z0-9-]{10,}/g\n  ]\n};\n\nfunction IAPF_getActiveSS_() {\n  return SpreadsheetApp.getActiveSpreadsheet();\n}\n\nfunction IAPF_nowIso_() {\n  return new Date().toISOString();\n}\n\nfunction IAPF_getScriptProp_(key) {\n  const p \u003d PropertiesService.getScriptProperties();\n  return p.getProperty(IAPF.PROP_PREFIX + key);\n}\n\nfunction IAPF_setScriptProp_(key, value) {\n  const p \u003d PropertiesService.getScriptProperties();\n  if (value \u003d\u003d\u003d null || value \u003d\u003d\u003d undefined) return;\n  p.setProperty(IAPF.PROP_PREFIX + key, String(value).trim());\n}\n\nfunction IAPF_guardNoSecrets_(text, contextLabel) {\n  if (!text) return { ok: true, hits: [] };\n  const hits \u003d [];\n  IAPF.SECRET_PATTERNS.forEach((re) \u003d\u003e {\n    const m \u003d text.match(re);\n    if (m \u0026\u0026 m.length) {\n      hits.push({ pattern: String(re), matches: Array.from(new Set(m)).slice(0, 3) });\n    }\n  });\n  if (hits.length) {\n    IAPF_log_(\"WARN\", \"SECRET_DETECTED\", `Secret-like pattern detected in ${contextLabel}. NOT storing raw content in logs.`, { hitsCount: hits.length });\n    return { ok: false, hits };\n  }\n  return { ok: true, hits: [] };\n}\n"},{"id":"cb84b35f-4540-4323-9332-ef8e38e9d8bd","name":"G01_UI_MENU","type":"server_js","source":"// File: /CODE/G01_UI_MENU.gs\n// HUB IAPF Memory V1 ‚Äî Menu principal + sous-menu MCP Cockpit\n\nfunction onOpen(e) {\n  IAPF_uiBuildMenu_();\n}\n\nfunction IAPF_uiBuildMenu_() {\n  const ui \u003d SpreadsheetApp.getUi();\n\n  // --- Sous-menu MCP Cockpit (attach√© au menu IAPF Memory)\n  const mcpMenu \u003d ui.createMenu(\"MCP Cockpit\")\n    .addItem(\"üîå Test Connection\", \"MCP_COCKPIT_testConnection\")\n    .addItem(\"üîç GET /infra/whoami\", \"MCP_COCKPIT_getWhoami\")\n    .addItem(\"üìä Test Pagination\", \"MCP_COCKPIT_testPagination\")\n    .addItem(\"üõ†Ô∏è HTTP GET Tool\", \"MCP_COCKPIT_httpGetTool\")\n    .addSeparator()\n    .addItem(\"üåê Audit Lecture Partout (P1)\", \"MCP_AUDIT_readEverywhere\")\n    .addSeparator()\n    .addItem(\"1Ô∏è‚É£ Initialiser Journ√©e\", \"MCP_ACTION_initializeDay\")\n    .addItem(\"2Ô∏è‚É£ Cl√¥ture Journ√©e\", \"MCP_ACTION_closeDay\")\n    .addSeparator()\n    .addItem(\"3Ô∏è‚É£ Audit Global\", \"MCP_ACTION_globalAudit\")\n    .addItem(\"4Ô∏è‚É£ V√©rification Doc vs Code\", \"MCP_ACTION_verifyDocVsCode\")\n    .addItem(\"5Ô∏è‚É£ D√©ploiement Automatis√© (SAFE)\", \"MCP_ACTION_automatedDeploy\")\n    .addSeparator()\n    .addItem(\"Audit complet HUB\", \"MCP_AUDIT_auditHub\")\n    .addItem(\"Audit BOX2026\", \"MCP_AUDIT_auditBox2026\")\n    .addSeparator()\n    .addItem(\"Export HUB (ZIP + XLSX Sheet)\", \"MCP_EXPORT_exportHubZipAndSheet\")\n    .addItem(\"Export BOX (ZIP + XLSX Sheet)\", \"MCP_EXPORT_exportBoxZipAndSheet\")\n    .addSeparator()\n    .addItem(\"V√©rifier coh√©rence d√©pendances\", \"MCP_DEPENDENCIES_checkConsistency\");\n  \n  // --- Sous-menu Actions MCP Phase 2 (18 endpoints)\n  const actionsMcpMenu \u003d ui.createMenu(\"Actions MCP\")\n    .addItem(\"üìÅ Drive ‚Äî List Tree\", \"MCP_ACTION_driveListTree\")\n    .addItem(\"üìÑ Drive ‚Äî File Metadata\", \"MCP_ACTION_driveFileMetadata\")\n    .addItem(\"üîç Drive ‚Äî Search\", \"MCP_ACTION_driveSearch\")\n    .addSeparator()\n    .addItem(\"üìú Apps Script ‚Äî Deployments\", \"MCP_ACTION_appsScriptDeployments\")\n    .addItem(\"üèóÔ∏è Apps Script ‚Äî Structure\", \"MCP_ACTION_appsScriptStructure\")\n    .addSeparator()\n    .addItem(\"‚òÅÔ∏è Cloud Run ‚Äî Service Status\", \"MCP_ACTION_cloudRunServiceStatus\")\n    .addSeparator()\n    .addItem(\"üîê Secret Manager ‚Äî List\", \"MCP_ACTION_secretsList\")\n    .addItem(\"üîë Secret Manager ‚Äî Get Reference\", \"MCP_ACTION_secretGetReference\")\n    .addItem(\"‚ûï Secret Manager ‚Äî Create (DRY_RUN)\", \"MCP_ACTION_secretCreateDryRun\")\n    .addItem(\"‚úÖ Secret Manager ‚Äî Create (APPLY)\", \"MCP_ACTION_secretCreateApply\")\n    .addSeparator()\n    .addItem(\"üåê Web ‚Äî Search\", \"MCP_ACTION_webSearch\")\n    .addSeparator()\n    .addItem(\"üíª Terminal ‚Äî Run (READ_ONLY)\", \"MCP_ACTION_terminalRunReadOnly\");\n\n  // --- Menu principal IAPF Memory\n  ui.createMenu(IAPF.MENU_NAME)\n    .addItem(\"Initialiser / Valider HUB\", \"IAPF_initHub\")\n    .addSeparator()\n    .addItem(\"Inventaire Drive (rechercher existants)\", \"IAPF_inventoryDrive\")\n    .addSeparator()\n    .addItem(\"G√©n√©rer Snapshot\", \"IAPF_generateSnapshot\")\n    .addItem(\"Exporter Context Pack\", \"IAPF_exportContextPack\")\n    .addSeparator()\n    .addItem(\"Ajouter d√©cision / r√®gle / constat\", \"IAPF_uiAddMemoryEntry\")\n    .addItem(\"Ajouter / maj erreur Orion\", \"IAPF_uiUpsertError\")\n    .addSeparator()\n    .addItem(\"Installer / Mettre √† jour trigger daily (06:00)\", \"IAPF_installDailyTrigger\")\n    .addSeparator()\n    // IMPORTANT: ouvre le dossier ARCHIVES (pas BACKUP_BOX2026)\n    .addItem(\"BOX2026 ‚Äî Ouvrir dossier ARCHIVES\", \"MCP_UI_openArchivesFolder\")\n    .addSeparator()\n    .addSubMenu(mcpMenu)\n    .addSubMenu(actionsMcpMenu)\n    .addSeparator()\n    .addItem(\"Ouvrir LOGS\", \"IAPF_uiOpenLogs\")\n    .addToUi();\n}\n\nfunction IAPF_uiOpenLogs() {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.LOGS_SHEET);\n  if (sh) ss.setActiveSheet(sh);\n}\n\nfunction IAPF_uiAddMemoryEntry() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const typeResp \u003d ui.prompt(\"Type\", \"DECISION / REGLE / CONSTAT\", ui.ButtonSet.OK_CANCEL);\n  if (typeResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n\n  const titleResp \u003d ui.prompt(\"Titre\", \"Titre court\", ui.ButtonSet.OK_CANCEL);\n  if (titleResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n\n  const detailsResp \u003d ui.prompt(\"D√©tails\", \"D√©tails (1-3 phrases, factuel)\", ui.ButtonSet.OK_CANCEL);\n  if (detailsResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n\n  const type \u003d String(typeResp.getResponseText() || \"\").trim().toUpperCase();\n  const title \u003d String(titleResp.getResponseText() || \"\").trim();\n  const details \u003d String(detailsResp.getResponseText() || \"\").trim();\n\n  if (!type || !title) {\n    ui.alert(\"Champs manquants\", \"Type et Titre sont obligatoires.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  // append-only MEMORY_LOG (g√©r√© par ton module 03_MEMORY_WRITE)\n  IAPF_memoryAppendLogRow({\n    type,\n    title,\n    details,\n    author: Session.getActiveUser().getEmail() || \"unknown\",\n    source: \"UI\",\n    tags: \"ORION;HUB\"\n  });\n\n  ui.alert(\"OK\", \"Entr√©e ajout√©e dans MEMORY_LOG.\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_uiUpsertError() {\n  // D√©l√©gu√© au module erreurs existant (si pr√©sent)\n  if (typeof IAPF_uiUpsertErrorImpl_ \u003d\u003d\u003d \"function\") return IAPF_uiUpsertErrorImpl_();\n  SpreadsheetApp.getUi().alert(\"Fonction indisponible\", \"IAPF_uiUpsertErrorImpl_ introuvable.\", SpreadsheetApp.getUi().ButtonSet.OK);\n}\n\n/**\n * Ouvre le dossier ARCHIVES d√©fini dans SETTINGS.archives_folder_id\n */\nfunction MCP_UI_openArchivesFolder() {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.SETTINGS_SHEET);\n  if (!sh) {\n    SpreadsheetApp.getUi().alert(\"SETTINGS manquant\", \"Onglet SETTINGS introuvable.\", SpreadsheetApp.getUi().ButtonSet.OK);\n    return;\n  }\n\n  const values \u003d sh.getDataRange().getValues();\n  let archivesId \u003d \"\";\n  for (let i \u003d 1; i \u003c values.length; i++) {\n    const k \u003d String(values[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d \"archives_folder_id\") {\n      archivesId \u003d String(values[i][1] || \"\").trim();\n      break;\n    }\n  }\n\n  if (!archivesId) {\n    SpreadsheetApp.getUi().alert(\n      \"SETTINGS manquant\",\n      \"Ajoute la cl√© SETTINGS:archives_folder_id \u003d \u003cID dossier Drive ARCHIVES\u003e.\",\n      SpreadsheetApp.getUi().ButtonSet.OK\n    );\n    return;\n  }\n\n  const url \u003d \"https://drive.google.com/drive/folders/\" + archivesId;\n  const html \u003d HtmlService.createHtmlOutput(\n    \u0027\u003cscript\u003ewindow.open(\"\u0027 + url + \u0027\",\"_blank\");google.script.host.close();\u003c/script\u003e\u0027\n  ).setWidth(180).setHeight(40);\n\n  SpreadsheetApp.getUi().showModalDialog(html, \"Ouverture ARCHIVES\");\n}\n\n/**\n * \u003d\u003d\u003d\u003d\u003d 5 NOUVELLES ACTIONS MCP \u003d\u003d\u003d\u003d\u003d\n * Ces fonctions sont appel√©es depuis le sous-menu MCP Cockpit.\n * Elles doivent √™tre impl√©ment√©es dans G07_MCP_COCKPIT.gs ou √©quivalent.\n */\n\n// 1Ô∏è‚É£ Initialiser Journ√©e\nfunction MCP_ACTION_initializeDay() {\n  if (typeof MCP_IMPL_initializeDay \u003d\u003d\u003d \"function\") {\n    return MCP_IMPL_initializeDay();\n  }\n  SpreadsheetApp.getUi().alert(\n    \"Action MCP\",\n    \"MCP_IMPL_initializeDay() non trouv√©e.\\nAjoute cette fonction dans G07_MCP_COCKPIT.gs.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\n// 2Ô∏è‚É£ Cl√¥ture Journ√©e\nfunction MCP_ACTION_closeDay() {\n  if (typeof MCP_IMPL_closeDay \u003d\u003d\u003d \"function\") {\n    return MCP_IMPL_closeDay();\n  }\n  SpreadsheetApp.getUi().alert(\n    \"Action MCP\",\n    \"MCP_IMPL_closeDay() non trouv√©e.\\nAjoute cette fonction dans G07_MCP_COCKPIT.gs.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\n// 3Ô∏è‚É£ Audit Global\nfunction MCP_ACTION_globalAudit() {\n  if (typeof MCP_IMPL_globalAudit \u003d\u003d\u003d \"function\") {\n    return MCP_IMPL_globalAudit();\n  }\n  SpreadsheetApp.getUi().alert(\n    \"Action MCP\",\n    \"MCP_IMPL_globalAudit() non trouv√©e.\\nAjoute cette fonction dans G07_MCP_COCKPIT.gs.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\n// 4Ô∏è‚É£ V√©rification Doc vs Code\nfunction MCP_ACTION_verifyDocVsCode() {\n  if (typeof MCP_IMPL_verifyDocVsCode \u003d\u003d\u003d \"function\") {\n    return MCP_IMPL_verifyDocVsCode();\n  }\n  SpreadsheetApp.getUi().alert(\n    \"Action MCP\",\n    \"MCP_IMPL_verifyDocVsCode() non trouv√©e.\\nAjoute cette fonction dans G07_MCP_COCKPIT.gs.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\n// 5Ô∏è‚É£ D√©ploiement Automatis√©\nfunction MCP_ACTION_automatedDeploy() {\n  if (typeof MCP_IMPL_automatedDeploy \u003d\u003d\u003d \"function\") {\n    return MCP_IMPL_automatedDeploy();\n  }\n  SpreadsheetApp.getUi().alert(\n    \"Action MCP\",\n    \"MCP_IMPL_automatedDeploy() non trouv√©e.\\nAjoute cette fonction dans G07_MCP_COCKPIT.gs.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n"},{"id":"cb7842a4-9624-4da7-9c83-ea031a0c2a33","name":"G02_SNAPSHOT_ENGINE","type":"server_js","source":"// File: /CODE/02_SNAPSHOT_ENGINE.gs\n\n// -----------------------------------------------------------------------------\n// COMPATIBILIT√â MCP (menu \"MCP Cockpit\")\n// Le menu appelle \"MCP_SNAPSHOT_generate\". Cette fonction n\u0027existait pas dans\n// certains exports, ce qui provoque l\u0027erreur :\n//   \"Fonction de script introuvable : MCP_SNAPSHOT_generate\"\n// On ajoute un wrapper non destructif qui d√©l√®gue au moteur officiel IAPF.\n// -----------------------------------------------------------------------------\n\nfunction MCP_SNAPSHOT_generate() {\n  return IAPF_generateSnapshot();\n}\n\nfunction IAPF_generateSnapshot() {\n  const op \u003d IAPF_generateSnapshot_();\n  const ui \u003d SpreadsheetApp.getUi();\n  if (!op.ok) {\n    ui.alert(\"Snapshot: ERREUR\", op.error || \"Unknown error\", ui.ButtonSet.OK);\n    return;\n  }\n  ui.alert(\"Snapshot: OK\", \"SNAPSHOT_ACTIVE mis √† jour. Snapshot Drive cr√©√© si configur√©.\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_exportContextPack() {\n  const op \u003d IAPF_buildContextPack_();\n  const ui \u003d SpreadsheetApp.getUi();\n  if (!op.ok) {\n    ui.alert(\"Context Pack: ERREUR\", op.error || \"Unknown error\", ui.ButtonSet.OK);\n    return;\n  }\n  ui.alert(\"CONTEXT PACK\", op.text || \"(vide)\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_generateSnapshot_() {\n  try {\n    IAPF_initHub_({ quiet: true });\n\n    const memItems \u003d IAPF_readLastMemoryEntries_(IAPF.MAX_MEMORY_ITEMS);\n    const errors \u003d IAPF_readErrorsActive_();\n    const roadmapHint \u003d IAPF_getRoadmapHint_();\n\n    const lines \u003d [];\n    lines.push(`IAPF ‚Äî SNAPSHOT ACTIF`);\n    lines.push(`generated: ${IAPF_nowIso_()}`);\n    lines.push(\"\");\n\n    lines.push(\"CONTEXTE ACTIF\");\n    const ctxLines \u003d IAPF_buildContextLines_(memItems, roadmapHint);\n    ctxLines.forEach(l \u003d\u003e lines.push(l));\n    if (!ctxLines.length) lines.push(\"- (aucune entr√©e m√©moire r√©cente)\");\n\n    lines.push(\"\");\n    lines.push(\"R√àGLES \u0026 ERREURS ACTIVES\");\n    const ruleErrLines \u003d IAPF_buildRulesErrorsLines_(errors);\n    ruleErrLines.forEach(l \u003d\u003e lines.push(l));\n    if (!ruleErrLines.length) lines.push(\"- (aucune erreur active)\");\n\n    const snapshotText \u003d lines.join(\"\\n\").trim();\n\n    IAPF_writeSnapshotActive_(snapshotText);\n\n    const ioRes \u003d IAPF_createDriveSnapshotIfConfigured_(snapshotText);\n    if (!ioRes.ok) {\n      IAPF_log_(\"WARN\", \"SNAPSHOT_DRIVE_NOT_CREATED\", ioRes.error || \"Drive snapshot not created\", {});\n    }\n\n    return { ok: true };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"SNAPSHOT_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_buildContextPack_() {\n  try {\n    IAPF_initHub_({ quiet: true });\n\n    const memItems \u003d IAPF_readLastMemoryEntries_(IAPF.MAX_MEMORY_ITEMS);\n    const errors \u003d IAPF_readErrorsActive_();\n    const roadmapHint \u003d IAPF_getRoadmapHint_();\n\n    const lines \u003d [];\n    lines.push(\"CONTEXT PACK ‚Äî IAPF\");\n    lines.push(`generated: ${IAPF_nowIso_()}`);\n    lines.push(\"\");\n    lines.push(\"1) CONTEXTE ACTIF\");\n    const ctxLines \u003d IAPF_buildContextLines_(memItems, roadmapHint, IAPF.MAX_LINES_CONTEXT);\n    ctxLines.forEach(l \u003d\u003e lines.push(l));\n    if (!ctxLines.length) lines.push(\"- (aucune entr√©e m√©moire r√©cente)\");\n    lines.push(\"\");\n    lines.push(\"2) R√àGLES \u0026 ERREURS ACTIVES\");\n    const ruleErrLines \u003d IAPF_buildRulesErrorsLines_(errors, 12);\n    ruleErrLines.forEach(l \u003d\u003e lines.push(l));\n    if (!ruleErrLines.length) lines.push(\"- (aucune erreur active)\");\n\n    const text \u003d lines.join(\"\\n\").trim();\n    return { ok: true, text };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"CONTEXT_PACK_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_buildContextLines_(memItems, roadmapHint, limit) {\n  const out \u003d [];\n  const max \u003d limit || IAPF.MAX_LINES_CONTEXT;\n\n  if (roadmapHint) {\n    out.push(`- Roadmap li√©e: ${roadmapHint}`);\n  }\n\n  memItems.slice(0, max).forEach((it) \u003d\u003e {\n    const t \u003d (it.type || \"\").toUpperCase();\n    const title \u003d it.title || \"\";\n    const ts \u003d it.ts_iso || \"\";\n    out.push(`- [${t}] ${title} (${ts})`);\n  });\n\n  return out.slice(0, max);\n}\n\nfunction IAPF_buildRulesErrorsLines_(errors, limit) {\n  const out \u003d [];\n  const max \u003d limit || 20;\n  errors.slice(0, max).forEach((e) \u003d\u003e {\n    out.push(`- ${e.code}: ${e.title} ‚Äî ${e.status}`);\n  });\n  return out.slice(0, max);\n}\n\nfunction IAPF_writeSnapshotActive_(snapshotText) {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.SNAPSHOT_SHEET);\n\n  sh.getRange(2, 1, Math.max(1, sh.getLastRow() - 1), 2).clearContent();\n\n  const ts \u003d IAPF_nowIso_();\n  sh.getRange(2, 1).setValue(ts);\n  sh.getRange(2, 2).setValue(snapshotText);\n\n  sh.setColumnWidths(1, 1, 220);\n  sh.setColumnWidths(2, 1, 900);\n  sh.getRange(1, 1, 1, 2).setFontWeight(\"bold\");\n  sh.getRange(2, 2).setWrap(true);\n}\n"},{"id":"d6dabfb8-59e5-47ad-bf50-6ef3f225a2f3","name":"G03_MEMORY_WRITE","type":"server_js","source":"// File: /CODE/G03_MEMORY_WRITE.gs\n\n/**\n * Get author email with safe fallback\n * Avoid MEMORY_APPEND_FAIL due to Session.getActiveUser() unavailable in some contexts\n */\nfunction _getAuthorSafe_() {\n  try {\n    const email \u003d Session.getActiveUser().getEmail();\n    if (email) return email;\n  } catch (e) {\n    // Session unavailable (trigger, API call, etc.)\n  }\n  \n  // Fallback: check if triggered by MCP/System\n  try {\n    const props \u003d PropertiesService.getScriptProperties();\n    const mcp_mode \u003d props.getProperty(\"IAPF_API_MODE\");\n    if (mcp_mode) return \"SYSTEM/MCP\";\n  } catch (e) {}\n  \n  // Last resort\n  return \"SYSTEM\";\n}\n\nfunction IAPF_appendMemoryEntry_(type, title, details, opts) {\n  // Backward-compatible call signature:\n  // - Legacy: IAPF_appendMemoryEntry_(type, title, details, opts)\n  // - New:    IAPF_appendMemoryEntry_({ type, title, details, source, tags, opts })\n  if (type \u0026\u0026 typeof type \u003d\u003d\u003d \"object\" \u0026\u0026 title \u003d\u003d\u003d undefined \u0026\u0026 details \u003d\u003d\u003d undefined \u0026\u0026 opts \u003d\u003d\u003d undefined) {\n    const payload \u003d type;\n    type \u003d payload.type;\n    title \u003d payload.title;\n    details \u003d payload.details;\n    const pOpts \u003d payload.opts \u0026\u0026 typeof payload.opts \u003d\u003d\u003d \"object\" ? payload.opts : {};\n    opts \u003d {\n      source: payload.source !\u003d\u003d undefined ? payload.source : (pOpts.source !\u003d\u003d undefined ? pOpts.source : \"\"),\n      tags: payload.tags !\u003d\u003d undefined ? payload.tags : (pOpts.tags !\u003d\u003d undefined ? pOpts.tags : \"\")\n    };\n  }\n\n  try {\n    IAPF_initHub_({ quiet: true });\n\n    const safeCheck \u003d IAPF_guardNoSecrets_(`${title}\\n${details}`, \"MEMORY_LOG\");\n    if (!safeCheck.ok) {\n      return { ok: false, error: \"Secret d√©tect√© (pattern). Stockage refus√©. Mettre en coffre + ScriptProperties.\" };\n    }\n\n    const ss \u003d IAPF_getActiveSS_();\n    const sh \u003d ss.getSheetByName(IAPF.MEMORY_LOG_SHEET);\n\n    const row \u003d [\n      IAPF_nowIso_(),\n      (type || \"CONSTAT\").toUpperCase(),\n      (title || \"\").trim(),\n      (details || \"\").trim(),\n      _getAuthorSafe_(),\n      (opts \u0026\u0026 opts.source) ? String(opts.source) : \"\",\n      (opts \u0026\u0026 opts.tags) ? String(opts.tags) : \"\"\n    ];\n\n    sh.appendRow(row);\n    IAPF_log_(\"INFO\", \"MEMORY_APPEND_OK\", \"Appended entry to MEMORY_LOG\", { type: row[1], title: row[2] });\n\n    return { ok: true };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"MEMORY_APPEND_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_upsertError_(code, title, status, details) {\n  try {\n    IAPF_initHub_({ quiet: true });\n\n    const safeCheck \u003d IAPF_guardNoSecrets_(`${code}\\n${title}\\n${details}`, \"ERRORS\");\n    if (!safeCheck.ok) {\n      return { ok: false, error: \"Secret d√©tect√© (pattern). Stockage refus√©.\" };\n    }\n\n    const ss \u003d IAPF_getActiveSS_();\n    const sh \u003d ss.getSheetByName(IAPF.ERRORS_SHEET);\n\n    const now \u003d IAPF_nowIso_();\n    const rows \u003d sh.getDataRange().getValues();\n    const header \u003d rows[0] || [];\n\n    const idxCode \u003d header.indexOf(\"code\");\n    const idxTitle \u003d header.indexOf(\"title\");\n    const idxStatus \u003d header.indexOf(\"status\");\n    const idxDetails \u003d header.indexOf(\"details\");\n    const idxUpdatedAt \u003d header.indexOf(\"updated_at\");\n\n    if (idxCode \u003c 0) throw new Error(\"ERRORS header missing: code\");\n    if (idxTitle \u003c 0) throw new Error(\"ERRORS header missing: title\");\n    if (idxStatus \u003c 0) throw new Error(\"ERRORS header missing: status\");\n    if (idxDetails \u003c 0) throw new Error(\"ERRORS header missing: details\");\n    if (idxUpdatedAt \u003c 0) throw new Error(\"ERRORS header missing: updated_at\");\n\n    let foundRow \u003d -1;\n    for (let i \u003d 1; i \u003c rows.length; i++) {\n      if (String(rows[i][idxCode] || \"\").trim() \u003d\u003d\u003d String(code).trim()) {\n        foundRow \u003d i + 1; // 1-based\n        break;\n      }\n    }\n\n    const row \u003d new Array(header.length).fill(\"\");\n    row[idxCode] \u003d String(code || \"\").trim();\n    row[idxTitle] \u003d String(title || \"\").trim();\n    row[idxStatus] \u003d String(status || \"\").trim();\n    row[idxDetails] \u003d String(details || \"\").trim();\n    row[idxUpdatedAt] \u003d now;\n\n    if (foundRow \u003e 0) {\n      sh.getRange(foundRow, 1, 1, row.length).setValues([row]);\n      IAPF_log_(\"INFO\", \"ERROR_UPSERT_UPDATE\", \"Updated ERRORS row\", { code });\n    } else {\n      sh.appendRow(row);\n      IAPF_log_(\"INFO\", \"ERROR_UPSERT_INSERT\", \"Inserted ERRORS row\", { code });\n    }\n\n    return { ok: true };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"ERROR_UPSERT_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n"},{"id":"69350905-c34d-41c8-b887-8f8cc9a3dbcc","name":"G04_DRIVE_IO","type":"server_js","source":"// File: /CODE/04_DRIVE_IO.gs\n\nfunction IAPF_inventoryDrive() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const res \u003d IAPF_inventoryDrive_();\n  if (!res.ok) {\n    ui.alert(\"Inventaire Drive: ERREUR\", res.error || \"Unknown error\", ui.ButtonSet.OK);\n    return;\n  }\n  ui.alert(\"Inventaire Drive: OK\", res.summary || \"(voir LOGS / DRIVE_INVENTORY)\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_inventoryDrive_() {\n  try {\n    IAPF_initHub_({ quiet: true });\n\n    // 1) Root folder (OBLIGATOIRE)\n    const rootId \u003d IAPF_getConfig_(\"memory_root_folder_id\");\n    if (!rootId) {\n      return { ok: false, error: \"memory_root_folder_id non configur√© (onglet SETTINGS)\" };\n    }\n\n    // 2) Param√®tres scan (s√©curit√©s Apps Script)\n    const started \u003d Date.now();\n    const TIME_BUDGET_MS \u003d 4.5 * 60 * 1000; // \u003c 6 min, marge de s√©curit√©\n    const MAX_FOLDERS \u003d 5000;               // garde-fou\n    const MAX_FILES_PER_FOLDER \u003d 0;         // 0 \u003d ne pas lister les fichiers (focus architecture)\n    const MAX_DEPTH \u003d 30;                   // garde-fou\n    const runId \u003d IAPF_nowIso_().replace(/[:.]/g, \"-\");\n\n    // 3) Scan BFS (folders)\n    const rootFolder \u003d DriveApp.getFolderById(rootId);\n    const rootName \u003d rootFolder.getName();\n\n    const rows \u003d [];\n    const header \u003d [\"run_id\", \"ts_iso\", \"depth\", \"kind\", \"name\", \"id\", \"url\", \"parent_id\", \"path\"];\n\n    // Always include root\n    rows.push([\n      runId,\n      IAPF_nowIso_(),\n      0,\n      \"FOLDER\",\n      rootName,\n      rootId,\n      rootFolder.getUrl(),\n      \"\",\n      \"/\" + rootName\n    ]);\n\n    const queue \u003d [{ folder: rootFolder, depth: 0, path: \"/\" + rootName, parentId: \"\" }];\n    let foldersCount \u003d 1;\n    let filesCount \u003d 0;\n\n    while (queue.length \u003e 0) {\n      if (Date.now() - started \u003e TIME_BUDGET_MS) break;\n      if (foldersCount \u003e\u003d MAX_FOLDERS) break;\n\n      const cur \u003d queue.shift();\n      if (cur.depth \u003e\u003d MAX_DEPTH) continue;\n\n      // Subfolders\n      const sub \u003d cur.folder.getFolders();\n      while (sub.hasNext()) {\n        if (Date.now() - started \u003e TIME_BUDGET_MS) break;\n        if (foldersCount \u003e\u003d MAX_FOLDERS) break;\n\n        const f \u003d sub.next();\n        const id \u003d f.getId();\n        const name \u003d f.getName();\n        const url \u003d f.getUrl();\n        const depth \u003d cur.depth + 1;\n        const path \u003d cur.path + \"/\" + name;\n\n        rows.push([runId, IAPF_nowIso_(), depth, \"FOLDER\", name, id, url, cur.folder.getId(), path]);\n        foldersCount++;\n\n        queue.push({ folder: f, depth, path, parentId: cur.folder.getId() });\n      }\n\n      // Files (optionnel)\n      if (MAX_FILES_PER_FOLDER \u003e 0) {\n        const files \u003d cur.folder.getFiles();\n        let c \u003d 0;\n        while (files.hasNext() \u0026\u0026 c \u003c MAX_FILES_PER_FOLDER) {\n          if (Date.now() - started \u003e TIME_BUDGET_MS) break;\n          const fi \u003d files.next();\n          rows.push([\n            runId,\n            IAPF_nowIso_(),\n            cur.depth + 1,\n            \"FILE\",\n            fi.getName(),\n            fi.getId(),\n            fi.getUrl(),\n            cur.folder.getId(),\n            cur.path + \"/\" + fi.getName()\n          ]);\n          filesCount++;\n          c++;\n        }\n      }\n    }\n\n    const timedOut \u003d (Date.now() - started \u003e TIME_BUDGET_MS);\n    const clipped \u003d (foldersCount \u003e\u003d MAX_FOLDERS);\n\n    // 4) Ecriture onglet DRIVE_INVENTORY (clear + write)\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const invSheetName \u003d \"DRIVE_INVENTORY\";\n    const invSheet \u003d IAPF_getOrCreateSheet_(ss, invSheetName);\n\n    invSheet.clearContents();\n    invSheet.getRange(1, 1, 1, header.length).setValues([header]);\n    if (rows.length \u003e 0) {\n      invSheet.getRange(2, 1, rows.length, header.length).setValues(rows);\n    }\n    invSheet.autoResizeColumns(1, header.length);\n\n    // 5) V√©rif gouvernance : template canonique racine\n    const expected \u003d [\n      \"00_GOUVERNANCE\",\n      \"01_BOX_CENTRALE\",\n      \"02_PRODUCTION\",\n      \"03_CLIENTS\",\n      \"04_ENTREPRISE_IAPF\",\n      \"05_COMPTABILITE\",\n      \"06_DIGITAL\",\n      \"07_ACCES_PROTEGES\",\n      \"08_TESTS_LAB\",\n      \"09_ARCHIVES\",\n      \"99_LEGACY_HORS_SYSTEME\"\n    ];\n\n    const present \u003d {};\n    expected.forEach(n \u003d\u003e present[n] \u003d { found: false, id: \"\", url: \"\" });\n\n    // On ne check que le niveau 1 sous la racine\n    const top \u003d rootFolder.getFolders();\n    while (top.hasNext()) {\n      const f \u003d top.next();\n      const n \u003d f.getName();\n      if (present[n]) {\n        present[n].found \u003d true;\n        present[n].id \u003d f.getId();\n        present[n].url \u003d f.getUrl();\n      }\n    }\n\n    const govHeader \u003d [\"run_id\", \"ts_iso\", \"expected_folder\", \"present\", \"folder_id\", \"folder_url\"];\n    const govRows \u003d expected.map(n \u003d\u003e [\n      runId,\n      IAPF_nowIso_(),\n      n,\n      present[n].found ? \"YES\" : \"NO\",\n      present[n].id,\n      present[n].url\n    ]);\n\n    const govSheetName \u003d \"DRIVE_GOV_CHECK\";\n    const govSheet \u003d IAPF_getOrCreateSheet_(ss, govSheetName);\n    govSheet.clearContents();\n    govSheet.getRange(1, 1, 1, govHeader.length).setValues([govHeader]);\n    govSheet.getRange(2, 1, govRows.length, govHeader.length).setValues(govRows);\n    govSheet.autoResizeColumns(1, govHeader.length);\n\n    // 6) Snapshot texte opposable\n    const missing \u003d expected.filter(n \u003d\u003e !present[n].found);\n    const okCount \u003d expected.length - missing.length;\n\n    const snapshotLines \u003d [];\n    snapshotLines.push(\"IAPF ‚Äî DRIVE INVENTORY SNAPSHOT\");\n    snapshotLines.push(`generated: ${IAPF_nowIso_()}`);\n    snapshotLines.push(`run_id: ${runId}`);\n    snapshotLines.push(\"\");\n    snapshotLines.push(\"ROOT\");\n    snapshotLines.push(`- name: ${rootName}`);\n    snapshotLines.push(`- id: ${rootId}`);\n    snapshotLines.push(`- url: ${rootFolder.getUrl()}`);\n    snapshotLines.push(\"\");\n    snapshotLines.push(\"STATS\");\n    snapshotLines.push(`- folders_scanned: ${foldersCount}`);\n    snapshotLines.push(`- files_listed: ${filesCount}`);\n    snapshotLines.push(`- time_budget_hit: ${timedOut ? \"YES\" : \"NO\"}`);\n    snapshotLines.push(`- max_folders_hit: ${clipped ? \"YES\" : \"NO\"}`);\n    snapshotLines.push(\"\");\n    snapshotLines.push(\"GOV CHECK (ROOT TEMPLATE)\");\n    snapshotLines.push(`- expected: ${expected.length}`);\n    snapshotLines.push(`- present: ${okCount}`);\n    snapshotLines.push(`- missing: ${missing.length}`);\n    missing.forEach(n \u003d\u003e snapshotLines.push(`  - MISSING: ${n}`));\n    snapshotLines.push(\"\");\n    snapshotLines.push(\"NOTES\");\n    snapshotLines.push(\"- DRIVE_INVENTORY + DRIVE_GOV_CHECK √©crits dans le Hub.\");\n    snapshotLines.push(\"- Scan lecture seule (aucune cr√©ation/suppression de dossiers).\");\n\n    const snapshotText \u003d snapshotLines.join(\"\\n\");\n    const snapRes \u003d IAPF_createDriveSnapshotIfConfigured_(snapshotText);\n\n    // 7) Logs\n    IAPF_log_(\"INFO\", \"DRIVE_SCAN_DONE\", \"Drive scan completed\", {\n      runId,\n      rootId,\n      foldersCount,\n      filesCount,\n      timedOut,\n      clipped,\n      missing_root_folders: missing\n    });\n\n    // 8) Summary UI\n    const summaryLines \u003d [];\n    summaryLines.push(`run_id: ${runId}`);\n    summaryLines.push(`Racine: ${rootName}`);\n    summaryLines.push(`Dossiers scann√©s: ${foldersCount}`);\n    summaryLines.push(`Check gouvernance (racine): ${okCount}/${expected.length} OK`);\n    if (missing.length) summaryLines.push(`Manquants: ${missing.join(\", \")}`);\n    if (timedOut) summaryLines.push(\"ATTENTION: time budget atteint (scan partiel).\");\n    if (clipped) summaryLines.push(\"ATTENTION: MAX_FOLDERS atteint (scan partiel).\");\n    if (snapRes \u0026\u0026 snapRes.ok \u0026\u0026 snapRes.fileId) summaryLines.push(`Snapshot Drive: OK (${snapRes.fileId})`);\n\n    return { ok: true, summary: summaryLines.join(\"\\n\") };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"DRIVE_SCAN_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_createDriveSnapshotIfConfigured_(snapshotText) {\n  try {\n    const snapshotsFolderId \u003d IAPF_getConfig_(\"snapshots_folder_id\");\n    if (!snapshotsFolderId) {\n      return { ok: false, error: \"snapshots_folder_id non configur√©\" };\n    }\n\n    const folder \u003d DriveApp.getFolderById(snapshotsFolderId);\n    const ts \u003d IAPF_nowIso_().replace(/[:.]/g, \"-\");\n    const name \u003d `IAPF_DRIVE_SCAN_${ts}.txt`;\n\n    const file \u003d folder.createFile(name, snapshotText, MimeType.PLAIN_TEXT);\n    IAPF_log_(\"INFO\", \"SNAPSHOT_DRIVE_CREATED\", \"Created snapshot file in Drive\", { name, id: file.getId() });\n\n    return { ok: true, fileId: file.getId() };\n  } catch (err) {\n    IAPF_log_(\"WARN\", \"SNAPSHOT_DRIVE_CREATE_FAIL\", String(err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_ensureDriveFoldersConfigured_() {\n  const ui \u003d SpreadsheetApp.getUi();\n\n  let rootId \u003d IAPF_getConfig_(\"memory_root_folder_id\");\n  if (!rootId) {\n    const resp \u003d ui.prompt(\n      \"Configuration Drive requise\",\n      \"Colle memory_root_folder_id (dossier Drive racine m√©moire).\",\n      ui.ButtonSet.OK_CANCEL\n    );\n    if (resp.getSelectedButton() !\u003d\u003d ui.Button.OK) return { ok: false, error: \"Configuration annul√©e\" };\n    rootId \u003d (resp.getResponseText() || \"\").trim();\n    if (!rootId) return { ok: false, error: \"memory_root_folder_id vide\" };\n    IAPF_setConfig_(\"memory_root_folder_id\", rootId);\n  }\n\n  const rootFolder \u003d DriveApp.getFolderById(rootId);\n\n  let snapshotsId \u003d IAPF_getConfig_(\"snapshots_folder_id\");\n  if (!snapshotsId) {\n    const existing \u003d IAPF_findChildFolderByName_(rootFolder, \"M√©moire ‚Äî Snapshots\");\n    const folder \u003d existing || rootFolder.createFolder(\"M√©moire ‚Äî Snapshots\");\n    snapshotsId \u003d folder.getId();\n    IAPF_setConfig_(\"snapshots_folder_id\", snapshotsId);\n  }\n\n  let logsId \u003d IAPF_getConfig_(\"logs_folder_id\");\n  if (!logsId) {\n    const existing \u003d IAPF_findChildFolderByName_(rootFolder, \"M√©moire ‚Äî Logs\");\n    const folder \u003d existing || rootFolder.createFolder(\"M√©moire ‚Äî Logs\");\n    logsId \u003d folder.getId();\n    IAPF_setConfig_(\"logs_folder_id\", logsId);\n  }\n\n  return { ok: true, rootId, snapshotsId, logsId };\n}\n\nfunction IAPF_findChildFolderByName_(parentFolder, name) {\n  const it \u003d parentFolder.getFoldersByName(name);\n  if (it.hasNext()) return it.next();\n  return null;\n}\n\nfunction IAPF_getOrCreateSheet_(ss, name) {\n  let sh \u003d ss.getSheetByName(name);\n  if (!sh) sh \u003d ss.insertSheet(name);\n  return sh;\n}\n"},{"id":"f46fa233-9813-470e-b735-99f89915cc4b","name":"G05_LOGGER","type":"server_js","source":"// File: /CODE/05_LOGGER.gs\n\nfunction IAPF_log_(level, event, message, data) {\n  try {\n    const ss \u003d IAPF_getActiveSS_();\n    const sh \u003d ss.getSheetByName(IAPF.LOGS_SHEET);\n    if (!sh) return;\n\n    const payload \u003d data ? JSON.stringify(data).slice(0, 45000) : \"\";\n    sh.appendRow([IAPF_nowIso_(), String(level || \"INFO\"), String(event || \"\"), String(message || \"\"), payload]);\n  } catch (err) {\n    // last resort: do nothing\n  }\n}\n"},{"id":"67c5332d-8796-48a3-a651-ad3efc4a573d","name":"G06_BOX2026_TOOLS","type":"server_js","source":"// File: /CODE/06_BOX2026_TOOLS.gs\n//\n// BOX2026 helpers for HUB UI.\n// Governance: Drive-only read actions + safe link display.\n// No write to SNAPSHOT_ACTIVE here. No destructive operations.\n\nfunction IAPF_box2026OpenBackupFolder() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const folderId \u003d IAPF_getSettingValue_(\"box2026_backup_folder_id\");\n  if (!folderId) {\n    ui.alert(\n      \"SETTINGS manquant\",\n      \"Ajoute la cl√© SETTINGS: box2026_backup_folder_id \u003d \u003cID dossier Drive backups BOX2026\u003e.\",\n      ui.ButtonSet.OK\n    );\n    return;\n  }\n\n  const url \u003d \"https://drive.google.com/drive/folders/\" + encodeURIComponent(folderId);\n  IAPF_uiShowLink_(\"BOX2026 ‚Äî Dossier BACKUP\", url);\n}\n\nfunction IAPF_box2026DownloadLatestZip() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const folderId \u003d IAPF_getSettingValue_(\"box2026_backup_folder_id\");\n  if (!folderId) {\n    ui.alert(\n      \"SETTINGS manquant\",\n      \"Ajoute la cl√© SETTINGS: box2026_backup_folder_id \u003d \u003cID dossier Drive backups BOX2026\u003e.\",\n      ui.ButtonSet.OK\n    );\n    return;\n  }\n\n  let folder;\n  try {\n    folder \u003d DriveApp.getFolderById(folderId);\n  } catch (e) {\n    ui.alert(\"Erreur\", \"Impossible d\u0027ouvrir le dossier Drive: \" + String(e), ui.ButtonSet.OK);\n    return;\n  }\n\n  // Heuristique: on prend le ZIP le plus r√©cent dans ce dossier.\n  // Si tu veux filtrer par pr√©fixe exact (ex: APPS_SCRIPT_BACKUP_), on le fera ensuite.\n  const files \u003d folder.getFilesByType(MimeType.ZIP);\n  let latest \u003d null;\n\n  while (files.hasNext()) {\n    const f \u003d files.next();\n    if (!latest) {\n      latest \u003d f;\n      continue;\n    }\n    if (f.getDateCreated().getTime() \u003e latest.getDateCreated().getTime()) {\n      latest \u003d f;\n    }\n  }\n\n  if (!latest) {\n    ui.alert(\n      \"Aucun ZIP trouv√©\",\n      \"Aucun fichier .zip trouv√© dans le dossier. Lance d\u0027abord 99_BACKUP_ALL_BOX2026 c√¥t√© projet BOX2026 pour g√©n√©rer le ZIP.\",\n      ui.ButtonSet.OK\n    );\n    return;\n  }\n\n  // Lien direct Drive (download au clic via UI Drive).\n  const url \u003d \"https://drive.google.com/file/d/\" + encodeURIComponent(latest.getId()) + \"/view\";\n  IAPF_uiShowLink_(\"BOX2026 ‚Äî Dernier ZIP Apps Script\", url);\n}\n\n/** Minimal SETTINGS getter: reads key/value from SETTINGS sheet (columns A/B). */\nfunction IAPF_getSettingValue_(key) {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.SETTINGS_SHEET);\n  if (!sh) return \"\";\n\n  const values \u003d sh.getDataRange().getValues();\n  // Expect header row: key | value | notes\n  for (let i \u003d 1; i \u003c values.length; i++) {\n    const k \u003d String(values[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) return String(values[i][1] || \"\").trim();\n  }\n  return \"\";\n}\n\n/** Shows a clickable link via HtmlService dialog (alerts are not clickable). */\nfunction IAPF_uiShowLink_(title, url) {\n  const html \u003d HtmlService.createHtmlOutput(\n    \u0027\u003cdiv style\u003d\"font-family:Arial,sans-serif;font-size:13px\"\u003e\u0027 +\n      \u0027\u003cp\u003e\u003cb\u003e\u0027 + IAPF_escapeHtml_(title) + \u0027\u003c/b\u003e\u003c/p\u003e\u0027 +\n      \u0027\u003cp\u003e\u003ca href\u003d\"\u0027 + IAPF_escapeHtml_(url) + \u0027\" target\u003d\"_blank\" rel\u003d\"noopener\"\u003eOuvrir / T√©l√©charger\u003c/a\u003e\u003c/p\u003e\u0027 +\n      \u0027\u003cp style\u003d\"color:#666\"\u003eSi ton navigateur bloque les popups, autorise-les pour Google Sheets.\u003c/p\u003e\u0027 +\n    \u0027\u003c/div\u003e\u0027\n  ).setWidth(420).setHeight(180);\n\n  SpreadsheetApp.getUi().showModalDialog(html, title);\n}\n\nfunction IAPF_escapeHtml_(s) {\n  return String(s)\n    .replace(/\u0026/g, \"\u0026amp;\")\n    .replace(/\u003c/g, \"\u0026lt;\")\n    .replace(/\u003e/g, \"\u0026gt;\")\n    .replace(/\"/g, \"\u0026quot;\")\n    .replace(/\u0027/g, \"\u0026#039;\");\n}\n"},{"id":"2ff26fb5-8b91-42f2-a226-405d9483ead1","name":"G06_MCP_COCKPIT","type":"server_js","source":"// File: /CODE/06_MCP_COCKPIT.gs\n//\n// MCP Cockpit UI actions from the HUB\n// - Exports (HUB + BOX) as: ZIP Apps Script + XLSX Sheet copy\n// - Optional: trigger Cloud Run Job \"healthcheck\" via Run API (if settings present)\n// - Guardrails: never write SNAPSHOT_ACTIVE directly, only via snapshot generator\n\n/**\n * \u003d\u003d\u003d\u003d\u003d Public menu actions \u003d\u003d\u003d\u003d\u003d\n */\n\nfunction MCP_auditHub() {\n  MCP_runHealthcheckOrExplain_(\"HUB\");\n}\n\nfunction MCP_auditBox2026() {\n  MCP_runHealthcheckOrExplain_(\"BOX2026\");\n}\n\nfunction MCP_exportHubBundle() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const archives \u003d MCP_getOrCreateArchivesFolder_();\n\n  const ts \u003d MCP_ts_();\n  const ss \u003d MCP_getActiveSS_();\n\n  // 1) Export HUB Apps Script project as ZIP\n  const hubZip \u003d MCP_exportBoundScriptAsZip_(archives, \"HUB_APPS_SCRIPT_BACKUP\", ts);\n\n  // 2) Export HUB Sheet as XLSX\n  const hubXlsx \u003d MCP_exportSpreadsheetAsXlsx_(ss.getId(), archives, \"HUB_SHEET_EXPORT\", ts);\n\n  ui.alert(\n    \"OK\",\n    \"Export HUB termin√©.\\n\\nZIP: \" + hubZip.getName() + \"\\nXLSX: \" + hubXlsx.getName() +\n      \"\\n\\nOuvre le dossier ARCHIVES pour t√©l√©charger.\",\n    ui.ButtonSet.OK\n  );\n}\n\nfunction MCP_exportBoxBundle() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const archives \u003d MCP_getOrCreateArchivesFolder_();\n\n  const boxScriptId \u003d MCP_requireSetting_(\"box2026_script_id\", \"ID du script Apps Script BOX2026 (Cyril).\");\n  if (!boxScriptId) return;\n\n  const boxSheetId \u003d MCP_requireSetting_(\"box2026_sheet_id\", \"ID de la Google Sheet BOX2026 (Cyril).\");\n  if (!boxSheetId) return;\n\n  const ts \u003d MCP_ts_();\n\n  // 1) Export BOX Apps Script project as ZIP (via Apps Script API)\n  const boxZip \u003d MCP_exportExternalAppsScriptProjectAsZip_(boxScriptId, archives, \"BOX2026_APPS_SCRIPT_BACKUP\", ts);\n\n  // 2) Export BOX Sheet as XLSX\n  const boxXlsx \u003d MCP_exportSpreadsheetAsXlsx_(boxSheetId, archives, \"BOX2026_SHEET_EXPORT\", ts);\n\n  ui.alert(\n    \"OK\",\n    \"Export BOX2026 termin√©.\\n\\nZIP: \" + boxZip.getName() + \"\\nXLSX: \" + boxXlsx.getName() +\n      \"\\n\\nOuvre le dossier ARCHIVES pour t√©l√©charger.\",\n    ui.ButtonSet.OK\n  );\n}\n\nfunction MCP_checkDependencies() {\n  // Minimal non-destructive placeholder: log + guidance\n  const ui \u003d SpreadsheetApp.getUi();\n\n  // Optionnel: tu peux brancher ici une vraie v√©rif interne (cartographie/d√©pendances)\n  // Pour l‚Äôinstant on respecte gouvernance: aucun ‚Äúauto-correct‚Äù.\n  const msg \u003d\n    \"Check d√©pendances (mode gouvern√©).\\n\\n\" +\n    \"1) Lance \u0027Audit complet HUB\u0027 (MCP Cockpit)\\n\" +\n    \"2) Le rapport MCP doit proposer les corrections\\n\" +\n    \"3) Tu valides puis seulement on applique.\\n\\n\" +\n    \"Aucune √©criture automatique sur SNAPSHOT_ACTIVE.\";\n  ui.alert(\"MCP Cockpit\", msg, ui.ButtonSet.OK);\n}\n\nfunction MCP_uiOpenArchivesFolder() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const folder \u003d MCP_getOrCreateArchivesFolder_();\n  ui.alert(\"ARCHIVES\", \"Dossier: \" + folder.getUrl(), ui.ButtonSet.OK);\n}\n\n/**\n * \u003d\u003d\u003d\u003d\u003d Cloud Run Job trigger (optional) \u003d\u003d\u003d\u003d\u003d\n * Requires Settings:\n * - mcp_project_id\n * - mcp_region\n * - mcp_job_healthcheck\n *\n * Uses UrlFetchApp + OAuth token.\n */\nfunction MCP_runHealthcheckOrExplain_(scopeLabel) {\n  const ui \u003d SpreadsheetApp.getUi();\n\n  const projectId \u003d MCP_getSetting_(\"mcp_project_id\");\n  const region \u003d MCP_getSetting_(\"mcp_region\");\n  const jobName \u003d MCP_getSetting_(\"mcp_job_healthcheck\");\n\n  if (!projectId || !region || !jobName) {\n    ui.alert(\n      \"MCP Cockpit ‚Äî Settings manquants\",\n      \"Pour d√©clencher l\u0027audit via le HUB, renseigne dans SETTINGS :\\n\" +\n        \"- mcp_project_id\\n- mcp_region\\n- mcp_job_healthcheck\\n\\n\" +\n        \"Ensuite relance: MCP Cockpit \u003e Audit complet HUB / Audit BOX2026.\",\n      ui.ButtonSet.OK\n    );\n    return;\n  }\n\n  // Cloud Run Jobs v2 API\n  const url \u003d \"https://run.googleapis.com/v2/projects/\" + encodeURIComponent(projectId) +\n              \"/locations/\" + encodeURIComponent(region) +\n              \"/jobs/\" + encodeURIComponent(jobName) + \":run\";\n\n  const token \u003d ScriptApp.getOAuthToken();\n  const payload \u003d {}; // No overrides for now (keep governance tight)\n\n  const resp \u003d UrlFetchApp.fetch(url, {\n    method: \"post\",\n    contentType: \"application/json\",\n    payload: JSON.stringify(payload),\n    muteHttpExceptions: true,\n    headers: { Authorization: \"Bearer \" + token }\n  });\n\n  const code \u003d resp.getResponseCode();\n  const body \u003d resp.getContentText() || \"\";\n\n  if (code \u003e\u003d 200 \u0026\u0026 code \u003c 300) {\n    ui.alert(\n      \"OK\",\n      \"Audit d√©clench√© (\" + scopeLabel + \").\\n\\n\" +\n        \"Va voir les logs Cloud Run Job (Observabilit√©) + le report g√©n√©r√© dans Drive (si ton job l‚Äô√©crit).\",\n      ui.ButtonSet.OK\n    );\n    return;\n  }\n\n  ui.alert(\n    \"Erreur Cloud Run Job\",\n    \"HTTP \" + code + \"\\n\\n\" +\n      \"Causes fr√©quentes:\\n\" +\n      \"- Scope OAuth insuffisant\\n\" +\n      \"- Permission run.jobs.run manquante pour le compte Apps Script\\n\" +\n      \"- Nom job / region / project incorrect\\n\\n\" +\n      \"R√©ponse:\\n\" + body.slice(0, 1500),\n    ui.ButtonSet.OK\n  );\n}\n\n/**\n * \u003d\u003d\u003d\u003d\u003d Exports helpers \u003d\u003d\u003d\u003d\u003d\n */\n\n/**\n * Export bound script (the HUB script) as ZIP into Drive folder.\n * Uses Apps Script API: projects.getContent (requires Advanced service or REST with OAuth).\n */\nfunction MCP_exportBoundScriptAsZip_(targetFolder, prefix, ts) {\n  const scriptId \u003d ScriptApp.getScriptId();\n  return MCP_exportExternalAppsScriptProjectAsZip_(scriptId, targetFolder, prefix, ts);\n}\n\n/**\n * Export any Apps Script project as ZIP using Apps Script API (REST).\n * Note: this exports the *sources* into a ZIP file generated here.\n */\nfunction MCP_exportExternalAppsScriptProjectAsZip_(scriptId, targetFolder, prefix, ts) {\n  const token \u003d ScriptApp.getOAuthToken();\n  const url \u003d \"https://script.googleapis.com/v1/projects/\" + encodeURIComponent(scriptId) + \"/content\";\n\n  const resp \u003d UrlFetchApp.fetch(url, {\n    method: \"get\",\n    muteHttpExceptions: true,\n    headers: { Authorization: \"Bearer \" + token }\n  });\n\n  const code \u003d resp.getResponseCode();\n  if (code \u003c 200 || code \u003e\u003d 300) {\n    throw new Error(\"Apps Script API error HTTP \" + code + \" \u003d\u003e \" + resp.getContentText());\n  }\n\n  const json \u003d JSON.parse(resp.getContentText());\n  const files \u003d (json.files || []);\n\n  // Create a ZIP in-memory\n  const blobs \u003d [];\n  files.forEach(function(f) {\n    const name \u003d (f.name || \"file\") + \".\" + (f.type || \"gs\");\n    const source \u003d f.source || \"\";\n    blobs.push(Utilities.newBlob(source, \"text/plain\", name));\n  });\n\n  const zipBlob \u003d Utilities.zip(blobs, prefix + \"_\" + ts + \".zip\");\n  return targetFolder.createFile(zipBlob);\n}\n\n/**\n * Export a spreadsheet as XLSX into Drive folder.\n */\nfunction MCP_exportSpreadsheetAsXlsx_(spreadsheetId, targetFolder, prefix, ts) {\n  const token \u003d ScriptApp.getOAuthToken();\n  const url \u003d\n    \"https://www.googleapis.com/drive/v3/files/\" + encodeURIComponent(spreadsheetId) +\n    \"/export?mimeType\u003dapplication/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n\n  const resp \u003d UrlFetchApp.fetch(url, {\n    method: \"get\",\n    muteHttpExceptions: true,\n    headers: { Authorization: \"Bearer \" + token }\n  });\n\n  const code \u003d resp.getResponseCode();\n  if (code \u003c 200 || code \u003e\u003d 300) {\n    throw new Error(\"Drive export error HTTP \" + code + \" \u003d\u003e \" + resp.getContentText());\n  }\n\n  const blob \u003d resp.getBlob().setName(prefix + \"_\" + ts + \".xlsx\");\n  return targetFolder.createFile(blob);\n}\n\n/**\n * \u003d\u003d\u003d\u003d\u003d Settings \u0026 folders \u003d\u003d\u003d\u003d\u003d\n */\n\nfunction MCP_getOrCreateArchivesFolder_() {\n  const ss \u003d MCP_getActiveSS_();\n  const archivesId \u003d MCP_getSetting_(\"archives_folder_id\");\n\n  if (archivesId) {\n    return DriveApp.getFolderById(archivesId);\n  }\n\n  // Fallback: create under memory_root_folder_id if present\n  const rootId \u003d MCP_getSetting_(\"memory_root_folder_id\");\n  if (!rootId) {\n    // Create the key and ask user to fill it (governance)\n    MCP_ensureSettingKeyExists_(\"archives_folder_id\", \"ID dossier Drive IA Process Factory / 09_ARCHIVES\");\n    const ui \u003d SpreadsheetApp.getUi();\n    ui.alert(\n      \"SETTINGS manquant\",\n      \"Ajoute la cl√© SETTINGS:archives_folder_id \u003d \u003cID dossier Drive IA Process Factory / 09_ARCHIVES\u003e.\\n\" +\n        \"Puis relance l‚Äôexport.\",\n      ui.ButtonSet.OK\n    );\n    throw new Error(\"Missing SETTINGS archives_folder_id\");\n  }\n\n  const root \u003d DriveApp.getFolderById(rootId);\n  // Create / reuse \"09_ARCHIVES\"\n  const it \u003d root.getFoldersByName(\"09_ARCHIVES\");\n  const folder \u003d it.hasNext() ? it.next() : root.createFolder(\"09_ARCHIVES\");\n\n  // Persist it for next time\n  MCP_setSetting_(\"archives_folder_id\", folder.getId(), \"Auto-created under memory_root_folder_id\");\n  return folder;\n}\n\nfunction MCP_requireSetting_(key, notes) {\n  const v \u003d MCP_getSetting_(key);\n  if (v) return v;\n\n  MCP_ensureSettingKeyExists_(key, notes || \"\");\n  SpreadsheetApp.getUi().alert(\n    \"SETTINGS manquant\",\n    \"Ajoute la cl√© SETTINGS:\" + key + \" \u003d \u003cvaleur\u003e.\\n\" + (notes ? (\"\\n\" + notes) : \"\"),\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n  return null;\n}\n\nfunction MCP_getSetting_(key) {\n  const ss \u003d MCP_getActiveSS_();\n  const sh \u003d ss.getSheetByName(\"SETTINGS\");\n  if (!sh) return \"\";\n\n  const values \u003d sh.getDataRange().getValues();\n  // Expect header: key | value | notes\n  for (let i \u003d 1; i \u003c values.length; i++) {\n    const k \u003d String(values[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) return String(values[i][1] || \"\").trim();\n  }\n  return \"\";\n}\n\nfunction MCP_setSetting_(key, value, notes) {\n  const ss \u003d MCP_getActiveSS_();\n  const sh \u003d ss.getSheetByName(\"SETTINGS\");\n  if (!sh) throw new Error(\"Missing SETTINGS sheet\");\n\n  const values \u003d sh.getDataRange().getValues();\n  for (let i \u003d 1; i \u003c values.length; i++) {\n    const k \u003d String(values[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) {\n      sh.getRange(i + 1, 2).setValue(value);\n      if (notes !\u003d\u003d undefined) sh.getRange(i + 1, 3).setValue(notes);\n      return;\n    }\n  }\n\n  sh.appendRow([key, value, notes || \"\"]);\n}\n\nfunction MCP_ensureSettingKeyExists_(key, notes) {\n  const ss \u003d MCP_getActiveSS_();\n  let sh \u003d ss.getSheetByName(\"SETTINGS\");\n  if (!sh) {\n    sh \u003d ss.insertSheet(\"SETTINGS\");\n    sh.getRange(1, 1, 1, 3).setValues([[\"key\", \"value\", \"notes\"]]);\n  }\n\n  const values \u003d sh.getDataRange().getValues();\n  for (let i \u003d 1; i \u003c values.length; i++) {\n    const k \u003d String(values[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) return;\n  }\n  sh.appendRow([key, \"\", notes || \"\"]);\n}\n\nfunction MCP_getActiveSS_() {\n  // Prefer your existing helper if present\n  if (typeof IAPF_getActiveSS_ \u003d\u003d\u003d \"function\") return IAPF_getActiveSS_();\n  return SpreadsheetApp.getActiveSpreadsheet();\n}\n\nfunction MCP_ts_() {\n  const d \u003d new Date();\n  const pad \u003d (n) \u003d\u003e (n \u003c 10 ? \"0\" + n : \"\" + n);\n  return (\n    d.getFullYear() +\n    pad(d.getMonth() + 1) +\n    pad(d.getDate()) +\n    \"_\" +\n    pad(d.getHours()) +\n    pad(d.getMinutes()) +\n    pad(d.getSeconds())\n  );\n}\n"},{"id":"ad023c11-f00d-430e-866c-46e520c7cbf9","name":"G07_MCP_COCKPIT","type":"server_js","source":"/**\n * FILE: 07_MCP_COCKPIT.gs\n * PROJECT: IAPF MEMORY HUB V1\n *\n * Objectif:\n * - Fournir des actions \"cockpit\" d√©clench√©es depuis le HUB (menus)\n * - Aucun automatique. Aucune √©criture destructive.\n * - Exports: ZIP code + XLSX du Sheet dans 09_ARCHIVES.\n *\n * Pr√©-requis:\n * - Advanced Google Services:\n *   - Drive API (Drive)\n *   - Apps Script API (Script)\n */\n\nvar MCP \u003d (function () {\n\n  function _ss() {\n    return SpreadsheetApp.getActiveSpreadsheet();\n  }\n\n  function _ui() {\n    return SpreadsheetApp.getUi();\n  }\n\n  function _getSettingsMap_() {\n    var sh \u003d _ss().getSheetByName(\"SETTINGS\");\n    if (!sh) throw new Error(\"Sheet SETTINGS introuvable.\");\n    var values \u003d sh.getDataRange().getValues();\n    var map \u003d {};\n    for (var i \u003d 1; i \u003c values.length; i++) {\n      var k \u003d (values[i][0] || \"\").toString().trim();\n      var v \u003d (values[i][1] || \"\").toString().trim();\n      if (k) map[k] \u003d v;\n    }\n    return map;\n  }\n\n  function _requireSettings_(keys, title) {\n    var s \u003d _getSettingsMap_();\n    var missing \u003d [];\n    keys.forEach(function (k) {\n      if (!s[k]) missing.push(k);\n    });\n\n    if (missing.length) {\n      _ui().alert(\n        title || \"SETTINGS manquant\",\n        \"Ajoute dans SETTINGS (col A\u003dkey, col B\u003dvalue) :\\n- \" + missing.join(\"\\n- \"),\n        _ui().ButtonSet.OK\n      );\n      return null;\n    }\n    return s;\n  }\n\n  function _getFolderById_(id) {\n    return DriveApp.getFolderById(id);\n  }\n\n  function _ts_() {\n    // YYYYMMDD_HHMMSS\n    var d \u003d new Date();\n    function pad(n) { return (n \u003c 10 ? \"0\" : \"\") + n; }\n    return d.getFullYear().toString()\n      + pad(d.getMonth() + 1)\n      + pad(d.getDate())\n      + \"_\"\n      + pad(d.getHours())\n      + pad(d.getMinutes())\n      + pad(d.getSeconds());\n  }\n\n  function _exportSheetXlsxBlob_(spreadsheetId, outName) {\n    // Drive API advanced service: Drive.Files.export\n    var blob;\n    try {\n      // Drive API advanced service (requires alt\u003dmedia)\n      blob \u003d Drive.Files.export(spreadsheetId, \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\", { alt: \"media\" });\n    } catch (e) {\n      // Fallback: raw HTTP export (also uses alt\u003dmedia)\n      blob \u003d _driveExportBlob_(spreadsheetId, \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n    }\n    blob.setName(outName);\n    return blob;\n  }\n\n  function _exportAppsScriptProjectZipBlob_(scriptId, zipName, prefixFolder) {\n    // 1) Try Script API (container-bound safe). 2) Fallback to Drive export JSON, then expand to files.\n    var ts \u003d Utilities.formatDate(new Date(), Session.getScriptTimeZone(), \"yyyyMMdd_HHmmss\");\n    var pfx \u003d (prefixFolder ? String(prefixFolder).replace(/\\/+$/,\"\") + \"/\" : \"\");\n\n    // --- A) Script API (best case)\n    try {\n      if (typeof Script !\u003d\u003d \"undefined\" \u0026\u0026 Script \u0026\u0026 Script.Projects \u0026\u0026 typeof Script.Projects.getContent \u003d\u003d\u003d \"function\") {\n        var project \u003d Script.Projects.getContent(String(scriptId));\n        var blobsA \u003d _projectFilesToBlobs_(project, pfx);\n        if (blobsA.length) {\n          var zA \u003d Utilities.zip(blobsA, zipName); zA.setName(zipName); return zA;\n        }\n      }\n    } catch (e) {\n      // fall through\n    }\n\n    // --- B) Drive export JSON (works even if Script API scopes are not granted yet)\n    var jsonBlob \u003d _driveExportBlob_(scriptId, \"application/vnd.google-apps.script+json\");\n    var jsonText \u003d \"\";\n    try { jsonText \u003d jsonBlob.getDataAsString(); } catch (e2) {}\n\n    try {\n      var projectB \u003d JSON.parse(jsonText || \"{}\");\n      var blobsB \u003d _projectFilesToBlobs_(projectB, pfx);\n\n      // Keep a copy of the raw json for audit/debug (optional but safe)\n      jsonBlob.setName(pfx + \"apps_script_project_\" + ts + \".json\");\n      blobsB.push(jsonBlob);\n\n      var zB \u003d Utilities.zip(blobsB, zipName); zB.setName(zipName); return zB;\n    } catch (e3) {\n      // Worst case: at least return the json as single file\n      jsonBlob.setName(pfx + \"apps_script_project_\" + ts + \".json\");\n      var zC \u003d Utilities.zip([jsonBlob], zipName); zC.setName(zipName); return zC;\n    }\n  }\n\n\n  \n  function _projectFilesToBlobs_(project, pfx) {\n    var blobs \u003d [];\n    var files \u003d (project \u0026\u0026 project.files) ? project.files : [];\n    files.forEach(function (f) {\n      if (!f || !f.name) return;\n      var t \u003d String(f.type || \"\").toUpperCase();\n      if (t \u003d\u003d\u003d \"SERVER_JS\") {\n        blobs.push(Utilities.newBlob(String(f.source || \"\"), \"text/plain\", pfx + f.name + \".gs\"));\n      } else if (t \u003d\u003d\u003d \"JSON\") {\n        blobs.push(Utilities.newBlob(String(f.source || \"\"), \"application/json\", pfx + f.name + \".json\"));\n      } else if (t \u003d\u003d\u003d \"HTML\") {\n        blobs.push(Utilities.newBlob(String(f.source || \"\"), \"text/html\", pfx + f.name + \".html\"));\n      } else {\n        // Keep unknown types as txt to avoid losing content\n        if (f.source !\u003d\u003d undefined) {\n          blobs.push(Utilities.newBlob(String(f.source || \"\"), \"text/plain\", pfx + f.name + \".txt\"));\n        }\n      }\n    });\n    return blobs;\n  }\n\nfunction _driveExportBlob_(fileId, mimeType) {\n    var token \u003d ScriptApp.getOAuthToken();\n    var url \u003d \"https://www.googleapis.com/drive/v3/files/\" +\n      encodeURIComponent(String(fileId)) +\n      \"/export?mimeType\u003d\" + encodeURIComponent(String(mimeType)) +\n      \"\u0026alt\u003dmedia\";\n\n    var resp \u003d UrlFetchApp.fetch(url, {\n      method: \"get\",\n      muteHttpExceptions: true,\n      followRedirects: true,\n      headers: { Authorization: \"Bearer \" + token }\n    });\n\n    var status \u003d resp.getResponseCode();\n    if (status !\u003d\u003d 200) {\n      var raw \u003d resp.getContentText() || \"\";\n      throw new Error(\"Drive export √©chou√© (HTTP \" + status + \"): \" + raw.substring(0, 300));\n    }\n    return resp.getBlob();\n  }\n\n  function _zipAll_(blobs, zipName) {\n    return Utilities.zip(blobs, zipName);\n  }\n\n  function _createFile_(folderId, blob) {\n    var folder \u003d _getFolderById_(folderId);\n    return folder.createFile(blob);\n  }\n\n  return {\n    requireSettings: _requireSettings_,\n    ts: _ts_,\n    exportSheetXlsxBlob: _exportSheetXlsxBlob_,\n    exportAppsScriptProjectZipBlob: _exportAppsScriptProjectZipBlob_,\n    zipAll: _zipAll_,\n    createFile: _createFile_\n  };\n\n})();\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  AUDITS (stubs gouvern√©s)\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction MCP_AUDIT_auditHub() {\n  // Ici: soit appel MCP r√©el (endpoint), soit simple ‚Äúlanceur‚Äù.\n  var s \u003d MCP.requireSettings(\n    [\"mcp_project_id\", \"mcp_region\", \"mcp_job_healthcheck\"],\n    \"MCP Cockpit ‚Äî Settings manquants\"\n  );\n  if (!s) return;\n\n  // Minimal safe: guide utilisateur (sans supposer ton endpoint exact)\n  SpreadsheetApp.getUi().alert(\n    \"Audit HUB\",\n    \"OK: settings MCP pr√©sents.\\n\\n√âtape suivante:\\n- D√©clencher le job MCP (healthcheck/audit) via ton cockpit MCP.\\n- Puis coller le r√©sultat dans MEMORY_LOG si besoin.\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\nfunction MCP_AUDIT_auditBox2026() {\n  var s \u003d MCP.requireSettings(\n    [\"box2026_script_id\", \"box2026_sheet_id\"],\n    \"MCP Cockpit ‚Äî Settings manquants\"\n  );\n  if (!s) return;\n\n  SpreadsheetApp.getUi().alert(\n    \"Audit BOX2026\",\n    \"OK: box2026_script_id + box2026_sheet_id pr√©sents.\\n\\nProchaine √©tape:\\n- Le vrai audit peut √™tre branch√© sur MCP (endpoint) si tu veux.\\n- Sinon, utilise Export BOX pour fournir un paquet complet (code+sheet).\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\nfunction MCP_AUDIT_checkDependenciesCoherence() {\n  // Ici tu brancheras ton analyse r√©elle (DEPENDANCES_SCRIPTS/CARTOGRAPHIE_APPELS).\n  SpreadsheetApp.getUi().alert(\n    \"Coh√©rence d√©pendances\",\n    \"Action cockpit pr√™te.\\n\\n√Ä brancher sur:\\n- lecture DEPENDANCES_SCRIPTS\\n- lecture CARTOGRAPHIE_APPELS\\n- d√©tection √©carts\\n- proposition corrections (sans appliquer automatiquement).\",\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  EXPORTS (HUB + BOX)\n *  ZIP \u003d code + XLSX sheet\n *  Output dans 09_ARCHIVES (archives_folder_id)\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction MCP_EXPORT_exportHubZipAndSheet() {\n  var s \u003d MCP.requireSettings(\n    [\"archives_folder_id\"],\n    \"MCP Cockpit ‚Äî Settings manquants\"\n  );\n  if (!s) return;\n\n  var ts \u003d MCP.ts();\n  var hubScriptId \u003d ScriptApp.getScriptId();\n  var hubSheetId \u003d SpreadsheetApp.getActiveSpreadsheet().getId();\n\n  var codeZip \u003d MCP.exportAppsScriptProjectZipBlob(\n    hubScriptId,\n    \"HUB_CODE__\" + ts + \".zip\",\n    \"CODE\"\n  );\n\n  var sheetXlsx \u003d MCP.exportSheetXlsxBlob(\n    hubSheetId,\n    \"HUB_SHEET__\" + ts + \".xlsx\"\n  );\n\n  // Zip final unique: CODE + XLSX\n  var finalZip \u003d MCP.zipAll(\n    [\n      // On r√©-emballe le zip code comme un fichier dans le zip final\n      codeZip.setName(\"HUB_CODE__\" + ts + \".zip\"),\n      sheetXlsx\n    ],\n    \"IAPF_HUB_EXPORT__\" + ts + \".zip\"\n  );\n\n  var f \u003d MCP.createFile(s.archives_folder_id, finalZip);\n\n  SpreadsheetApp.getUi().alert(\n    \"Export HUB termin√©\",\n    \"Fichier cr√©√© dans 09_ARCHIVES :\\n\" + f.getName(),\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n\nfunction MCP_EXPORT_exportBoxZipAndSheet() {\n  var s \u003d MCP.requireSettings(\n    [\"archives_folder_id\", \"box2026_script_id\", \"box2026_sheet_id\"],\n    \"MCP Cockpit ‚Äî Settings manquants\"\n  );\n  if (!s) return;\n\n  var ts \u003d MCP.ts();\n\n  var codeZip \u003d MCP.exportAppsScriptProjectZipBlob(\n    s.box2026_script_id,\n    \"BOX2026_CODE__\" + ts + \".zip\",\n    \"CODE\"\n  );\n\n  var sheetXlsx \u003d MCP.exportSheetXlsxBlob(\n    s.box2026_sheet_id,\n    \"BOX2026_SHEET__\" + ts + \".xlsx\"\n  );\n\n  var finalZip \u003d MCP.zipAll(\n    [\n      codeZip.setName(\"BOX2026_CODE__\" + ts + \".zip\"),\n      sheetXlsx\n    ],\n    \"BOX2026_EXPORT__\" + ts + \".zip\"\n  );\n\n  var f \u003d MCP.createFile(s.archives_folder_id, finalZip);\n\n  SpreadsheetApp.getUi().alert(\n    \"Export BOX2026 termin√©\",\n    \"Fichier cr√©√© dans 09_ARCHIVES :\\n\" + f.getName(),\n    SpreadsheetApp.getUi().ButtonSet.OK\n  );\n}\n"},{"id":"9b240ad6-f5a8-4ac4-9580-c2641af6691d","name":"G08_MCP_ACTIONS","type":"server_js","source":"// File: /CODE/G08_MCP_ACTIONS.gs\n// HUB IAPF Memory V1 ‚Äî Impl√©mentation des 5 actions MCP\n// PATCH SAFE ‚Äî Alias sheet resolver compatible RISKS/RISQUES + MEMORY_LOG headers tolerant\n\n/**\n * \u003d\u003d\u003d\u003d\u003d IMPL√âMENTATIONS MCP \u003d\u003d\u003d\u003d\u003d\n * Ces fonctions sont appel√©es depuis G01_UI_MENU.gs.\n * Conformes √† la gouvernance IAPF : aucune √©criture auto, confirmation humaine obligatoire.\n */\n\n// ---------- Helpers SAFE (no regression) ----------\n\nfunction IAPF__getSheetSafe_(ss, keyOrName) {\n  // Prefer alias resolver if available; fallback to direct name.\n  try {\n    if (typeof IAPF_SHEETS !\u003d\u003d \"undefined\" \u0026\u0026 IAPF_SHEETS \u0026\u0026 typeof IAPF_SHEETS.getSheet_ \u003d\u003d\u003d \"function\") {\n      return IAPF_SHEETS.getSheet_(keyOrName);\n    }\n  } catch (e) {}\n  try {\n    return ss.getSheetByName(String(keyOrName));\n  } catch (e2) {}\n  return null;\n}\n\nfunction IAPF__requiredSheetKeys_() {\n  // Canonical keys (RISKS key will map to RISQUES via alias layer)\n  return [\n    \"MEMORY_LOG\",\n    \"SNAPSHOT_ACTIVE\",\n    \"DEPENDANCES_SCRIPTS\",\n    \"CARTOGRAPHIE_APPELS\",\n    \"REGLES_DE_GOUVERNANCE\",\n    \"RISKS\",\n    \"CONFLITS_DETECTES\"\n  ];\n}\n\nfunction IAPF__checkMemoryHeaders_(memSheet) {\n  // Accept both legacy and new governance headers to avoid regression.\n  // legacy: [\"timestamp\",\"type\",\"title\",\"details\",\"author\",\"source\",\"tags\"]\n  // new:    [\"ts_iso\",\"type\",\"title\",\"details\",\"author\",\"source\",\"tags\"]\n  try {\n    const headers \u003d memSheet.getRange(1, 1, 1, 7).getValues()[0].map(h \u003d\u003e String(h).trim().toLowerCase());\n    const legacy \u003d [\"timestamp\", \"type\", \"title\", \"details\", \"author\", \"source\", \"tags\"];\n    const modern \u003d [\"ts_iso\", \"type\", \"title\", \"details\", \"author\", \"source\", \"tags\"];\n\n    const isLegacy \u003d headers.every((h, i) \u003d\u003e h \u003d\u003d\u003d legacy[i]);\n    const isModern \u003d headers.every((h, i) \u003d\u003e h \u003d\u003d\u003d modern[i]);\n\n    return (isLegacy || isModern);\n  } catch (e) {\n    return false;\n  }\n}\n\n// 1Ô∏è‚É£ Initialiser Journ√©e\nfunction MCP_IMPL_initializeDay() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const ss \u003d IAPF_getActiveSS_();\n\n  const response \u003d ui.alert(\n    \"MCP ‚Äî Initialiser Journ√©e\",\n    \"Cette action va :\\n\" +\n      \"‚Ä¢ Cr√©er un snapshot actif (SNAPSHOT_ACTIVE)\\n\" +\n      \"‚Ä¢ Enregistrer une entr√©e dans MEMORY_LOG\\n\" +\n      \"‚Ä¢ V√©rifier la coh√©rence des onglets HUB\\n\\n\" +\n      \"Continuer ?\",\n    ui.ButtonSet.YES_NO\n  );\n\n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  try {\n    // 1) Snapshot\n    if (typeof IAPF_generateSnapshot \u003d\u003d\u003d \"function\") {\n      IAPF_generateSnapshot();\n    }\n\n    // 2) Memory log\n    if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n      IAPF_appendMemoryEntry_({\n        type: \"DECISION\",\n        title: \"MCP ‚Äî Initialisation journ√©e\",\n        details: \"Snapshot actif g√©n√©r√© + v√©rification coh√©rence HUB\",\n        source: \"MCP_COCKPIT\",\n        tags: \"MCP;INIT\"\n      });\n    }\n\n    // 3) V√©rif coh√©rence (non destructif)\n    const keys \u003d IAPF__requiredSheetKeys_();\n    const missing \u003d keys.filter(k \u003d\u003e !IAPF__getSheetSafe_(ss, k));\n\n    if (missing.length \u003e 0) {\n      ui.alert(\n        \"MCP ‚Äî Init\",\n        \"‚ö†Ô∏è Onglets manquants : \" + missing.join(\", \") + \"\\n\\n\" +\n          \"Lance IAPF \u003e Initialiser / Valider HUB pour cr√©er les onglets.\",\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\n        \"MCP ‚Äî Init\",\n        \"‚úÖ Snapshot cr√©√©\\n‚úÖ MEMORY_LOG mis √† jour\\n‚úÖ Tous les onglets HUB pr√©sents\",\n        ui.ButtonSet.OK\n      );\n    }\n\n  } catch (e) {\n    ui.alert(\"MCP ‚Äî Init\", \"Erreur : \" + String(e \u0026\u0026 e.message ? e.message : e), ui.ButtonSet.OK);\n  }\n}\n\n// 2Ô∏è‚É£ Cl√¥ture Journ√©e\nfunction MCP_IMPL_closeDay() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const ss \u003d IAPF_getActiveSS_();\n\n  const response \u003d ui.alert(\n    \"MCP ‚Äî Cl√¥ture Journ√©e\",\n    \"Cette action va :\\n\" +\n      \"‚Ä¢ Exporter un snapshot final (XLSX + ZIP)\\n\" +\n      \"‚Ä¢ Enregistrer une entr√©e dans MEMORY_LOG\\n\" +\n      \"‚Ä¢ Archiver dans le dossier ARCHIVES\\n\\n\" +\n      \"Continuer ?\",\n    ui.ButtonSet.YES_NO\n  );\n\n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  try {\n    // 1) Export HUB\n    if (typeof MCP_exportHubBundle \u003d\u003d\u003d \"function\") {\n      MCP_exportHubBundle();\n    }\n\n    // 2) Memory log\n    if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n      IAPF_appendMemoryEntry_({\n        type: \"CONSTAT\",\n        title: \"MCP ‚Äî Cl√¥ture journ√©e\",\n        details: \"Export HUB + BOX2026 archiv√© dans ARCHIVES\",\n        source: \"MCP_COCKPIT\",\n        tags: \"MCP;CLOSE\"\n      });\n    }\n\n    ui.alert(\n      \"MCP ‚Äî Cl√¥ture\",\n      \"‚úÖ Export HUB r√©alis√©\\n‚úÖ MEMORY_LOG mis √† jour\\n\\n\" +\n        \"Ouvre le dossier ARCHIVES pour t√©l√©charger.\",\n      ui.ButtonSet.OK\n    );\n\n  } catch (e) {\n    ui.alert(\"MCP ‚Äî Cl√¥ture\", \"Erreur : \" + String(e \u0026\u0026 e.message ? e.message : e), ui.ButtonSet.OK);\n  }\n}\n\n// 3Ô∏è‚É£ Audit Global\nfunction MCP_IMPL_globalAudit() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const ss \u003d IAPF_getActiveSS_();\n\n  const response \u003d ui.alert(\n    \"MCP ‚Äî Audit Global\",\n    \"Cette action va :\\n\" +\n      \"‚Ä¢ Scanner TOUS les onglets du HUB (structure + contenu)\\n\" +\n      \"‚Ä¢ Mettre √† jour CARTOGRAPHIE_APPELS (analyse code)\\n\" +\n      \"‚Ä¢ Mettre √† jour DEPENDANCES_SCRIPTS (analyse imports)\\n\" +\n      \"‚Ä¢ D√©tecter conflits et incoh√©rences\\n\" +\n      \"‚Ä¢ G√©n√©rer snapshot audit complet\\n\\n\" +\n      \"Continuer ?\",\n    ui.ButtonSet.YES_NO\n  );\n\n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  try {\n    // \u003d\u003d\u003d PHASE 1: Scan tous les onglets \u003d\u003d\u003d\n    const allSheets \u003d ss.getSheets();\n    const sheetInfo \u003d [];\n    \n    for (let i \u003d 0; i \u003c allSheets.length; i++) {\n      const sh \u003d allSheets[i];\n      sheetInfo.push({\n        name: sh.getName(),\n        rows: sh.getLastRow(),\n        cols: sh.getLastColumn(),\n        index: i\n      });\n    }\n\n    // \u003d\u003d\u003d PHASE 2: Analyse CARTOGRAPHIE_APPELS \u003d\u003d\u003d\n    const scriptId \u003d ScriptApp.getScriptId();\n    let functionsFound \u003d [];\n    \n    try {\n      const token \u003d ScriptApp.getOAuthToken();\n      const url \u003d \"https://script.googleapis.com/v1/projects/\" + scriptId + \"/content\";\n      const resp \u003d UrlFetchApp.fetch(url, {\n        method: \"get\",\n        headers: { \"Authorization\": \"Bearer \" + token },\n        muteHttpExceptions: true\n      });\n      \n      if (resp.getResponseCode() \u003d\u003d\u003d 200) {\n        const content \u003d JSON.parse(resp.getContentText());\n        const files \u003d content.files || [];\n        \n        files.forEach(function(f) {\n          if (f.type \u003d\u003d\u003d \"SERVER_JS\") {\n            const source \u003d f.source || \"\";\n            // Extract function declarations: function NAME(...) {\n            const regex \u003d /function\\s+([A-Z_][A-Za-z0-9_]*)\\s*\\(/g;\n            let match;\n            while ((match \u003d regex.exec(source)) !\u003d\u003d null) {\n              functionsFound.push({\n                file: f.name,\n                function: match[1]\n              });\n            }\n          }\n        });\n      }\n    } catch (e) {\n      // OAuth scope missing or API disabled\n      functionsFound.push({ file: \"ERROR\", function: \"Apps Script API unavailable: \" + String(e.message) });\n    }\n\n    // \u003d\u003d\u003d PHASE 3: Mise √† jour CARTOGRAPHIE_APPELS \u003d\u003d\u003d\n    const cartoSheet \u003d IAPF__getSheetSafe_(ss, \"CARTOGRAPHIE_APPELS\");\n    if (cartoSheet) {\n      // Clear and rewrite\n      cartoSheet.clear();\n      cartoSheet.appendRow([\"file\", \"function\", \"updated_at\"]);\n      \n      const now \u003d IAPF_nowIso_();\n      functionsFound.forEach(function(item) {\n        cartoSheet.appendRow([item.file, item.function, now]);\n      });\n    }\n\n    // \u003d\u003d\u003d PHASE 4: Mise √† jour DEPENDANCES_SCRIPTS \u003d\u003d\u003d\n    const depsSheet \u003d IAPF__getSheetSafe_(ss, \"DEPENDANCES_SCRIPTS\");\n    if (depsSheet) {\n      // For now, just mark as scanned\n      // Real dependency analysis would require parsing imports/calls\n      depsSheet.clear();\n      depsSheet.appendRow([\"file\", \"depends_on\", \"updated_at\"]);\n      depsSheet.appendRow([\"GLOBAL\", \"Audit scan executed\", IAPF_nowIso_()]);\n    }\n\n    // \u003d\u003d\u003d PHASE 5: D√©tection conflits \u003d\u003d\u003d\n    const keys \u003d IAPF__requiredSheetKeys_();\n    const missing \u003d keys.filter(k \u003d\u003e !IAPF__getSheetSafe_(ss, k));\n    const memLog \u003d IAPF__getSheetSafe_(ss, \"MEMORY_LOG\");\n    const memoryOk \u003d memLog ? IAPF__checkMemoryHeaders_(memLog) : false;\n\n    // \u003d\u003d\u003d PHASE 6: Rapport \u003d\u003d\u003d\n    const report \u003d [\n      \"\u003d\u003d\u003d AUDIT GLOBAL HUB (TRANSVERSAL) \u003d\u003d\u003d\",\n      \"\",\n      \"Date: \" + IAPF_nowIso_(),\n      \"\",\n      \"1) ONGLETS SCANN√âS\",\n      \"Total: \" + allSheets.length,\n      \"D√©tails: \" + sheetInfo.map(function(s) { return s.name + \" (\" + s.rows + \" rows)\"; }).join(\", \"),\n      \"\",\n      \"2) ONGLETS REQUIS\",\n      \"Pr√©sents: \" + (keys.length - missing.length) + \" / \" + keys.length,\n      \"Manquants: \" + (missing.length \u003e 0 ? missing.join(\", \") : \"aucun\"),\n      \"\",\n      \"3) CARTOGRAPHIE_APPELS\",\n      \"Fonctions d√©tect√©es: \" + functionsFound.length,\n      \"Mise √† jour: \" + (cartoSheet ? \"‚úÖ OK\" : \"‚ùå Sheet manquant\"),\n      \"\",\n      \"4) DEPENDANCES_SCRIPTS\",\n      \"Mise √† jour: \" + (depsSheet ? \"‚úÖ OK\" : \"‚ùå Sheet manquant\"),\n      \"\",\n      \"5) STRUCTURE MEMORY_LOG\",\n      \"Status: \" + (memoryOk ? \"‚úÖ OK (7 colonnes)\" : \"‚ö†Ô∏è INVALIDE\"),\n      \"\",\n      \"6) CONFLITS D√âTECT√âS\",\n      \"Count: 0 (analyse manuelle recommand√©e)\",\n      \"\"\n    ].join(\"\\n\");\n\n    ui.alert(\"MCP ‚Äî Audit Global (Transversal)\", report, ui.ButtonSet.OK);\n\n    // \u003d\u003d\u003d PHASE 7: Log audit \u003d\u003d\u003d\n    if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n      IAPF_appendMemoryEntry_({\n        type: \"CONSTAT\",\n        title: \"MCP ‚Äî Audit global HUB (transversal complet)\",\n        details: \"Onglets: \" + allSheets.length + \" | Fonctions: \" + functionsFound.length + \" | MEMORY_LOG: \" + (memoryOk ? \"OK\" : \"INVALIDE\"),\n        source: \"MCP_COCKPIT\",\n        tags: \"MCP;AUDIT;TRANSVERSAL\"\n      });\n    }\n\n  } catch (e) {\n    ui.alert(\"MCP ‚Äî Audit\", \"Erreur : \" + String(e \u0026\u0026 e.message ? e.message : e), ui.ButtonSet.OK);\n  }\n}\n\n// 4Ô∏è‚É£ V√©rification Doc vs Code\nfunction MCP_IMPL_verifyDocVsCode() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const ss \u003d IAPF_getActiveSS_();\n\n  const response \u003d ui.alert(\n    \"MCP ‚Äî V√©rification Doc vs Code\",\n    \"Cette action va :\\n\" +\n      \"‚Ä¢ Lire CARTOGRAPHIE_APPELS (doc attendue)\\n\" +\n      \"‚Ä¢ Scanner le code Apps Script r√©el\\n\" +\n      \"‚Ä¢ Comparer et d√©tecter √©carts\\n\" +\n      \"‚Ä¢ G√©n√©rer rapport diff\\n\\n\" +\n      \"Note: n√©cessite Apps Script API activ√©e + scope OAuth\\n\\n\" +\n      \"Continuer ?\",\n    ui.ButtonSet.YES_NO\n  );\n\n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  try {\n    // \u003d\u003d\u003d PHASE 1: Lire CARTOGRAPHIE_APPELS (doc) \u003d\u003d\u003d\n    const cartoSheet \u003d IAPF__getSheetSafe_(ss, \"CARTOGRAPHIE_APPELS\");\n    const docFunctions \u003d [];\n    \n    if (cartoSheet \u0026\u0026 cartoSheet.getLastRow() \u003e 1) {\n      const values \u003d cartoSheet.getDataRange().getValues();\n      for (let i \u003d 1; i \u003c values.length; i++) {\n        const file \u003d String(values[i][0] || \"\").trim();\n        const func \u003d String(values[i][1] || \"\").trim();\n        if (file \u0026\u0026 func) {\n          docFunctions.push({ file: file, function: func });\n        }\n      }\n    }\n\n    // \u003d\u003d\u003d PHASE 2: Scanner code Apps Script r√©el \u003d\u003d\u003d\n    const scriptId \u003d ScriptApp.getScriptId();\n    const codeFunctions \u003d [];\n    let apiError \u003d null;\n    \n    try {\n      const token \u003d ScriptApp.getOAuthToken();\n      const url \u003d \"https://script.googleapis.com/v1/projects/\" + scriptId + \"/content\";\n      const resp \u003d UrlFetchApp.fetch(url, {\n        method: \"get\",\n        headers: { \"Authorization\": \"Bearer \" + token },\n        muteHttpExceptions: true\n      });\n      \n      const statusCode \u003d resp.getResponseCode();\n      if (statusCode \u003d\u003d\u003d 200) {\n        const content \u003d JSON.parse(resp.getContentText());\n        const files \u003d content.files || [];\n        \n        files.forEach(function(f) {\n          if (f.type \u003d\u003d\u003d \"SERVER_JS\") {\n            const source \u003d f.source || \"\";\n            const regex \u003d /function\\s+([A-Z_][A-Za-z0-9_]*)\\s*\\(/g;\n            let match;\n            while ((match \u003d regex.exec(source)) !\u003d\u003d null) {\n              codeFunctions.push({ file: f.name, function: match[1] });\n            }\n          }\n        });\n      } else if (statusCode \u003d\u003d\u003d 403) {\n        apiError \u003d \"OAuth scope manquant: https://www.googleapis.com/auth/script.projects.readonly\";\n      } else if (statusCode \u003d\u003d\u003d 404) {\n        apiError \u003d \"API Apps Script non activ√©e dans GCP Console\";\n      } else {\n        apiError \u003d \"HTTP \" + statusCode + \": \" + resp.getContentText().slice(0, 200);\n      }\n    } catch (e) {\n      apiError \u003d \"Exception: \" + String(e.message || e);\n    }\n\n    // \u003d\u003d\u003d PHASE 3: Comparaison \u003d\u003d\u003d\n    if (apiError) {\n      ui.alert(\n        \"MCP ‚Äî Doc vs Code\",\n        \"‚ö†Ô∏è Impossible de scanner le code\\n\\n\" +\n        \"Erreur: \" + apiError + \"\\n\\n\" +\n        \"Actions requises:\\n\" +\n        \"1) Activer l\u0027API Apps Script dans GCP Console\\n\" +\n        \"2) Ajouter scope OAuth dans appsscript.json:\\n\" +\n        \"   https://www.googleapis.com/auth/script.projects.readonly\\n\" +\n        \"3) Relancer l\u0027audit\",\n        ui.ButtonSet.OK\n      );\n      \n      if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n        IAPF_appendMemoryEntry_({\n          type: \"CONSTAT\",\n          title: \"MCP ‚Äî Doc vs Code (√©chec API)\",\n          details: \"Erreur: \" + apiError,\n          source: \"MCP_COCKPIT\",\n          tags: \"MCP;VERIFY;ERROR\"\n        });\n      }\n      return;\n    }\n\n    // \u003d\u003d\u003d PHASE 4: Calcul √©carts \u003d\u003d\u003d\n    const docSet \u003d new Set(docFunctions.map(function(f) { return f.file + \"::\" + f.function; }));\n    const codeSet \u003d new Set(codeFunctions.map(function(f) { return f.file + \"::\" + f.function; }));\n    \n    const inDocNotCode \u003d docFunctions.filter(function(f) {\n      return !codeSet.has(f.file + \"::\" + f.function);\n    });\n    \n    const inCodeNotDoc \u003d codeFunctions.filter(function(f) {\n      return !docSet.has(f.file + \"::\" + f.function);\n    });\n\n    // \u003d\u003d\u003d PHASE 5: Rapport \u003d\u003d\u003d\n    const report \u003d [\n      \"\u003d\u003d\u003d DOC vs CODE \u003d\u003d\u003d\",\n      \"\",\n      \"Date: \" + IAPF_nowIso_(),\n      \"\",\n      \"1) FONCTIONS DOCUMENT√âES (CARTOGRAPHIE_APPELS)\",\n      \"Total: \" + docFunctions.length,\n      \"\",\n      \"2) FONCTIONS DANS LE CODE\",\n      \"Total: \" + codeFunctions.length,\n      \"\",\n      \"3) √âCARTS\",\n      \"Dans doc, absentes du code: \" + inDocNotCode.length,\n      inDocNotCode.slice(0, 5).map(function(f) { return \"  - \" + f.file + \"::\" + f.function; }).join(\"\\n\"),\n      inDocNotCode.length \u003e 5 ? \"  ... (+\" + (inDocNotCode.length - 5) + \" autres)\" : \"\",\n      \"\",\n      \"Dans code, absentes de doc: \" + inCodeNotDoc.length,\n      inCodeNotDoc.slice(0, 5).map(function(f) { return \"  - \" + f.file + \"::\" + f.function; }).join(\"\\n\"),\n      inCodeNotDoc.length \u003e 5 ? \"  ... (+\" + (inCodeNotDoc.length - 5) + \" autres)\" : \"\",\n      \"\",\n      \"4) R√âSULTAT\",\n      inDocNotCode.length \u003d\u003d\u003d 0 \u0026\u0026 inCodeNotDoc.length \u003d\u003d\u003d 0 ? \"‚úÖ Doc et Code 100% align√©s\" : \"‚ö†Ô∏è √âcarts d√©tect√©s - mise √† jour recommand√©e\"\n    ].join(\"\\n\");\n\n    ui.alert(\"MCP ‚Äî Doc vs Code\", report, ui.ButtonSet.OK);\n\n    // \u003d\u003d\u003d PHASE 6: Log \u003d\u003d\u003d\n    if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n      IAPF_appendMemoryEntry_({\n        type: \"CONSTAT\",\n        title: \"MCP ‚Äî V√©rification Doc vs Code\",\n        details: \"Doc: \" + docFunctions.length + \" | Code: \" + codeFunctions.length + \" | √âcarts: \" + (inDocNotCode.length + inCodeNotDoc.length),\n        source: \"MCP_COCKPIT\",\n        tags: \"MCP;VERIFY;DIFF\"\n      });\n    }\n\n  } catch (e) {\n    ui.alert(\"MCP ‚Äî Doc vs Code\", \"Erreur : \" + String(e \u0026\u0026 e.message ? e.message : e), ui.ButtonSet.OK);\n  }\n}\n\n// 5Ô∏è‚É£ D√©ploiement Automatis√© (SAFE Mode)\nfunction MCP_IMPL_automatedDeploy() {\n  const ui \u003d SpreadsheetApp.getUi();\n\n  // SAFE MODE: Read deployment mode from SETTINGS\n  let deployMode \u003d \"DRY_RUN\"; // Default safe mode\n  try {\n    if (typeof IAPF_getConfig_ \u003d\u003d\u003d \"function\") {\n      const cfg \u003d IAPF_getConfig_(\"mcp_deploy_mode\");\n      if (cfg \u0026\u0026 [\"PRODUCTION\", \"STAGING\", \"DRY_RUN\"].indexOf(String(cfg).toUpperCase()) \u003e\u003d 0) {\n        deployMode \u003d String(cfg).toUpperCase();\n      }\n    }\n  } catch (e) {}\n\n  const response \u003d ui.alert(\n    \"MCP ‚Äî D√©ploiement Automatis√© (SAFE)\",\n    \"Cette action va :\\n\" +\n      \"‚Ä¢ D√©clencher un Cloud Run Job de d√©ploiement\\n\" +\n      \"‚Ä¢ Synchroniser HUB + BOX2026\\n\" +\n      \"‚Ä¢ Enregistrer une entr√©e dans MEMORY_LOG\\n\\n\" +\n      \"Mode actuel : \" + deployMode + \"\\n\" +\n      (deployMode \u003d\u003d\u003d \"DRY_RUN\" ? \"‚úÖ Mode SAFE : aucune action destructive\\n\" : \"\") +\n      (deployMode \u003d\u003d\u003d \"PRODUCTION\" ? \"‚ö†Ô∏è ATTENTION : d√©ploiement en PRODUCTION\\n\" : \"\") +\n      \"\\nContinuer ?\",\n    ui.ButtonSet.YES_NO\n  );\n\n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e.\", ui.ButtonSet.OK);\n    return;\n  }\n\n  try {\n    ui.alert(\n      \"MCP ‚Äî D√©ploiement\",\n      \"‚ÑπÔ∏è Action en mode \" + deployMode + \"\\n\\n\" +\n        \"Pour activer cette fonction :\\n\" +\n        \"1) Configure un Cloud Run Job \u0027mcp-deploy-iapf\u0027\\n\" +\n        \"2) Ajoute les settings dans SETTINGS :\\n\" +\n        \"   - mcp_project_id\\n\" +\n        \"   - mcp_region\\n\" +\n        \"   - mcp_job_deploy\\n\" +\n        \"   - mcp_deploy_mode (PRODUCTION/STAGING/DRY_RUN)\\n\" +\n        \"3) Impl√©mente l\u0027appel API dans G08_MCP_ACTIONS.gs\\n\\n\" +\n        \"Note : Mode DRY_RUN \u003d lecture seule, aucune action destructive\",\n      ui.ButtonSet.OK\n    );\n\n    if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n      IAPF_appendMemoryEntry_({\n        type: \"CONSTAT\",\n        title: \"MCP ‚Äî D√©ploiement automatis√© (non impl√©ment√©, mode \" + deployMode + \")\",\n        details: \"N√©cessite Cloud Run Job + settings GCP. Mode actuel : \" + deployMode,\n        source: \"MCP_COCKPIT\",\n        tags: \"MCP;DEPLOY;SAFE\"\n      });\n    }\n\n  } catch (e) {\n    ui.alert(\"MCP ‚Äî D√©ploiement\", \"Erreur : \" + String(e \u0026\u0026 e.message ? e.message : e), ui.ButtonSet.OK);\n  }\n}\n"},{"id":"4e2c0a53-bc8a-4732-a49b-b724e945e87f","name":"G09_API_ENDPOINT","type":"server_js","source":"/**\n * G09_API_ENDPOINT.gs\n * WebApp entrypoint: doPost/doGet -\u003e secure dispatcher\n */\n\nfunction doPost(e) {\n  return IAPF_API.handleRequest_(e);\n}\n\nfunction doGet(e) {\n  // Healthcheck minimal, no secrets, no internal details.\n  const out \u003d {\n    ok: true,\n    service: \"IAPF_MCP_WEBAPP\",\n    mode: IAPF_API.getMode_(),\n    time: new Date().toISOString()\n  };\n  return ContentService\n    .createTextOutput(JSON.stringify(out))\n    .setMimeType(ContentService.MimeType.JSON);\n}\n\nvar IAPF_API \u003d (function () {\n\n  function handleRequest_(e) {\n    const nowIso \u003d new Date().toISOString();\n    let requestId \u003d \"unknown\";\n    try {\n      const rawBody \u003d (e \u0026\u0026 e.postData \u0026\u0026 e.postData.contents) ? e.postData.contents : \"\";\n      const headers \u003d (e \u0026\u0026 e.parameter) ? e.parameter : {}; // Note: WebApp doesn\u0027t pass headers directly\n      // We\u0027ll read token via query param fallback ONLY if needed (discouraged).\n      // Recommended: token in body for WebApp limitation unless using external proxy.\n      const parsed \u003d rawBody ? JSON.parse(rawBody) : {};\n\n      requestId \u003d (parsed \u0026\u0026 parsed.request_id) ? String(parsed.request_id) : \"unknown\";\n      const token \u003d extractToken_(e, parsed);\n\n      // AUTH\n      const auth \u003d IAPF_AUTH.authorizeRequest(token, parsed);\n      if (!auth.ok) {\n        safeLog_(nowIso, \"CONSTAT\", \"API_AUTH_REFUSED\", {\n          request_id: requestId,\n          reason: auth.reason\n        }, \"API\");\n        return jsonOut_(403, {\n          ok: false,\n          mode: getMode_(),\n          request_id: requestId,\n          dry_run: true,\n          errors: [{ code: \"AUTH_REFUSED\", message: auth.reason }]\n        });\n      }\n\n      // Attach role to request for downstream gating (dispatcher).\n      // Note: keep internal field name underscore-prefixed to avoid collisions.\n      parsed._auth \u003d { role: String(auth.role || \"OPERATOR\") };\n\n      // VALIDATE ENVELOPE\n      const v \u003d validateEnvelope_(parsed);\n      if (!v.ok) {\n        safeLog_(nowIso, \"CONSTAT\", \"API_INVALID_REQUEST\", {\n          request_id: requestId,\n          errors: v.errors\n        }, \"API\");\n        return jsonOut_(400, {\n          ok: false,\n          mode: getMode_(),\n          request_id: requestId,\n          dry_run: true,\n          errors: v.errors\n        });\n      }\n\n      // DISPATCH\n      const dispatch \u003d IAPF_DISPATCH.dispatch(parsed);\n\n      // LOG (always)\n      safeLog_(nowIso,\n        dispatch.ok ? (dispatch.dry_run ? \"CONSTAT\" : \"DECISION\") : \"CONSTAT\",\n        dispatch.log_title,\n        dispatch.log_details,\n        \"API\"\n      );\n\n      return jsonOut_(200, dispatch.response);\n\n    } catch (err) {\n      safeLog_(nowIso, \"CONSTAT\", \"API_CRASH\", {\n        request_id: requestId,\n        message: String(err \u0026\u0026 err.message ? err.message : err)\n      }, \"API\");\n\n      return jsonOut_(500, {\n        ok: false,\n        mode: getMode_(),\n        request_id: requestId,\n        dry_run: true,\n        errors: [{ code: \"SERVER_ERROR\", message: \"Internal error\" }]\n      });\n    }\n  }\n\n  function extractToken_(e, parsed) {\n    // WebApp header access is limited; safest pragmatic approach:\n    // token must be in body: parsed.auth.token\n    // (If you later add a proxy, you can pass headers to body.)\n    if (parsed \u0026\u0026 parsed.auth \u0026\u0026 parsed.auth.token) return String(parsed.auth.token);\n\n    // Optional fallback: ?token\u003d... for emergency manual tests (not recommended)\n    if (e \u0026\u0026 e.parameter \u0026\u0026 e.parameter.token) return String(e.parameter.token);\n\n    return \"\";\n  }\n\n  function validateEnvelope_(req) {\n    const errors \u003d [];\n    if (!req || typeof req !\u003d\u003d \"object\") {\n      return { ok: false, errors: [{ code: \"INVALID_JSON\", message: \"Body must be JSON object\" }] };\n    }\n    if (!req.action || typeof req.action !\u003d\u003d \"string\") errors.push({ code: \"MISSING_ACTION\", message: \"action is required\" });\n    if (!req.request_id || typeof req.request_id !\u003d\u003d \"string\") errors.push({ code: \"MISSING_REQUEST_ID\", message: \"request_id is required\" });\n    if (!req.ts || typeof req.ts !\u003d\u003d \"string\") errors.push({ code: \"MISSING_TS\", message: \"ts is required\" });\n\n    // payload can be absent; will default to {}\n    if (req.payload \u0026\u0026 typeof req.payload !\u003d\u003d \"object\") errors.push({ code: \"INVALID_PAYLOAD\", message: \"payload must be object\" });\n\n    // confirm is optional boolean\n    if (req.confirm !\u003d\u003d undefined \u0026\u0026 typeof req.confirm !\u003d\u003d \"boolean\") {\n      errors.push({ code: \"INVALID_CONFIRM\", message: \"confirm must be boolean\" });\n    }\n\n    // confirm_token required only when confirm\u003dtrue\n    if (req.confirm \u003d\u003d\u003d true \u0026\u0026 (!req.confirm_token || typeof req.confirm_token !\u003d\u003d \"string\")) {\n      errors.push({ code: \"MISSING_CONFIRM_TOKEN\", message: \"confirm_token required when confirm\u003dtrue\" });\n    }\n\n    return { ok: errors.length \u003d\u003d\u003d 0, errors: errors };\n  }\n\n  function jsonOut_(statusCode, obj) {\n    // Apps Script ContentService doesn\u0027t allow setting HTTP status.\n    // We\u0027ll embed status in response for client handling.\n    const payload \u003d Object.assign({ http_status: statusCode }, obj);\n    return ContentService\n      .createTextOutput(JSON.stringify(payload))\n      .setMimeType(ContentService.MimeType.JSON);\n  }\n\n  function safeLog_(tsIso, type, title, detailsObj, source) {\n    // Always log via MEMORY_LOG writer (existing function)\n    try {\n      const details \u003d JSON.stringify(detailsObj || {});\n      IAPF_appendMemoryEntry(tsIso, type, title, details, Session.getActiveUser().getEmail() || \"system\", source || \"API\", \"IAPF;MCP;API\");\n    } catch (e) {\n      // last resort: avoid throwing\n      try { Logger.log(\"LOG_FAIL \" + String(e)); } catch (_) {}\n    }\n  }\n\n  function getMode_() {\n    return IAPF_AUTH.getApiMode_();\n  }\n\n  return {\n    handleRequest_: handleRequest_,\n    getMode_: getMode_\n  };\n\n})();\n"},{"id":"7a2f9781-5914-41da-a691-a109fcdd0425","name":"G10_AUTH","type":"server_js","source":"/**\n * G10_AUTH.gs\n * Token auth + anti-replay confirm_token mint/verify (usage unique).\n */\n\nvar IAPF_AUTH \u003d (function () {\n\n  function getApiMode_() {\n    const props \u003d PropertiesService.getScriptProperties();\n    return String(props.getProperty(\"IAPF_API_MODE\") || \"SAFE\");\n  }\n\n  function getToken_() {\n    const props \u003d PropertiesService.getScriptProperties();\n    return String(props.getProperty(\"IAPF_API_TOKEN\") || \"\");\n  }\n\n  function getAuditorToken_() {\n    // Optional secondary token dedicated to read-only auditors (e.g. √âlia).\n    // If not set, only IAPF_API_TOKEN is accepted.\n    const props \u003d PropertiesService.getScriptProperties();\n    return String(props.getProperty(\"IAPF_API_TOKEN_AUDITOR\") || \"\");\n  }\n\n  function getSalt_() {\n    const props \u003d PropertiesService.getScriptProperties();\n    return String(props.getProperty(\"IAPF_API_SALT\") || \"\");\n  }\n\n  function authorizeRequest(token, req) {\n    const expected \u003d getToken_();\n    if (!expected || expected.length \u003c 24) {\n      return { ok: false, reason: \"API token not configured\" };\n    }\n\n    var role \u003d \"\";\n    if (token \u0026\u0026 token \u003d\u003d\u003d expected) {\n      role \u003d \"OPERATOR\";\n    } else {\n      const auditor \u003d getAuditorToken_();\n      if (auditor \u0026\u0026 auditor.length \u003e\u003d 24 \u0026\u0026 token \u003d\u003d\u003d auditor) {\n        role \u003d \"AUDITOR\";\n      } else {\n        return { ok: false, reason: \"Invalid token\" };\n      }\n    }\n\n    // minimal time sanity (avoid accidental replay with stale payload)\n    // SAFE mode: reject if ts older than 10 minutes\n    try {\n      const mode \u003d getApiMode_();\n      if (mode \u003d\u003d\u003d \"SAFE\") {\n        const ts \u003d new Date(String(req.ts || \"\"));\n        const now \u003d new Date();\n        const ageMs \u003d Math.abs(now.getTime() - ts.getTime());\n        if (isNaN(ts.getTime())) return { ok: false, reason: \"Invalid ts\" };\n        if (ageMs \u003e 10 * 60 * 1000) return { ok: false, reason: \"Stale request\" };\n      }\n    } catch (e) {\n      return { ok: false, reason: \"Invalid ts\" };\n    }\n\n    return { ok: true, role: role };\n  }\n\n  function mintConfirmToken(planObj) {\n    // confirm token: short-lived nonce, usage unique\n    // store in Script Cache or Properties (cache is better, but not always reliable across quotas)\n    const nonce \u003d Utilities.getUuid();\n    const salt \u003d getSalt_();\n    const payload \u003d JSON.stringify(planObj || {});\n    const sig \u003d Utilities.base64Encode(Utilities.computeHmacSha256Signature(payload + \"|\" + nonce, salt));\n    const token \u003d nonce + \".\" + sig;\n\n    // store nonce as \"unused\" for 5 minutes\n    CacheService.getScriptCache().put(\"IAPF_CONFIRM_\" + nonce, \"1\", 300);\n\n    return token;\n  }\n\n  function verifyAndConsumeConfirmToken(token, planObj) {\n    if (!token || typeof token !\u003d\u003d \"string\" || token.indexOf(\".\") \u003d\u003d\u003d -1) return { ok: false, reason: \"Invalid confirm token\" };\n    const parts \u003d token.split(\".\");\n    if (parts.length !\u003d\u003d 2) return { ok: false, reason: \"Invalid confirm token\" };\n\n    const nonce \u003d parts[0];\n    const sig \u003d parts[1];\n\n    // must exist and be unused\n    const cache \u003d CacheService.getScriptCache();\n    const state \u003d cache.get(\"IAPF_CONFIRM_\" + nonce);\n    if (!state) return { ok: false, reason: \"Confirm token expired or already used\" };\n\n    const salt \u003d getSalt_();\n    const payload \u003d JSON.stringify(planObj || {});\n    const expectedSig \u003d Utilities.base64Encode(Utilities.computeHmacSha256Signature(payload + \"|\" + nonce, salt));\n\n    if (sig !\u003d\u003d expectedSig) return { ok: false, reason: \"Confirm token mismatch\" };\n\n    // consume\n    cache.remove(\"IAPF_CONFIRM_\" + nonce);\n\n    return { ok: true };\n  }\n\n  return {\n    getApiMode_: getApiMode_,\n    authorizeRequest: authorizeRequest,\n    mintConfirmToken: mintConfirmToken,\n    verifyAndConsumeConfirmToken: verifyAndConsumeConfirmToken\n  };\n\n})();\n"},{"id":"0b112322-4138-4107-a230-ad07abc8ec38","name":"G11_SHEET_ALIAS","type":"server_js","source":"/**\n * G11_SHEET_ALIAS.gs\n * Centralized sheet alias resolver (fix RISKS/RISQUES without patching every file).\n */\n\nvar IAPF_SHEETS \u003d (function () {\n\n  // Canonical keys used by code\n  var MAP \u003d {\n    \"MEMORY_LOG\": [\"MEMORY_LOG\"],\n    \"SNAPSHOT_ACTIVE\": [\"SNAPSHOT_ACTIVE\"],\n    \"CONFLITS_DETECTES\": [\"CONFLITS_DETECTES\"],\n    \"DEPENDANCES_SCRIPTS\": [\"DEPENDANCES_SCRIPTS\"],\n    \"CARTOGRAPHIE_APPELS\": [\"CARTOGRAPHIE_APPELS\"],\n    \"REGLES_DE_GOUVERNANCE\": [\"REGLES_DE_GOUVERNANCE\"],\n    \"RISKS\": [\"RISKS\", \"RISQUES\"] // \u003c‚Äî your issue fixed here\n  };\n\n  function resolveName_(key) {\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const names \u003d MAP[String(key)] || [String(key)];\n    for (var i \u003d 0; i \u003c names.length; i++) {\n      const sh \u003d ss.getSheetByName(names[i]);\n      if (sh) return names[i];\n    }\n    return null;\n  }\n\n  function getSheet_(key) {\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const name \u003d resolveName_(key);\n    if (!name) throw new Error(\"Sheet not found for key: \" + key);\n    return ss.getSheetByName(name);\n  }\n\n  function getName_(key) {\n    const name \u003d resolveName_(key);\n    if (!name) throw new Error(\"Sheet not found for key: \" + key);\n    return name;\n  }\n\n  return {\n    getSheet_: getSheet_,\n    getName_: getName_\n  };\n\n})();\n"},{"id":"75ee59a3-8858-4553-91e1-eef13334a3eb","name":"G12_API_DISPATCH","type":"server_js","source":"/**\n * G12_API_DISPATCH.gs\n * Allowlist dispatcher with dry-run default and confirm_token execution gate.\n * PATCH: add READ-only actions for GPT Desktop (no confirm needed).\n */\n\nvar IAPF_DISPATCH \u003d (function () {\n\n  var ALLOWLIST \u003d {\n    \"INITIALIZE_DAY\": true,\n    \"CLOSE_DAY\": true,\n    \"GENERATE_SNAPSHOT\": true,\n    \"APPEND_MEMORY_ENTRY\": true,\n    \"GLOBAL_AUDIT\": true,\n    \"EXPORT_HUB\": true,\n\n    // READ-only\n    \"READ_MEMORY_LOG\": true,\n    \"READ_SNAPSHOT_ACTIVE\": true,\n    \"READ_HUB_STATUS\": true,\n    \"LIST_ACTIONS\": true,\n\n    // READ-only connectors (inspection)\n    \"RO_DRIVE_TREE\": true,\n    \"RO_DRIVE_FILE_META\": true,\n    \"RO_DRIVE_CHANGES\": true,\n\n    \"RO_SCRIPT_PROJECT_DETAIL\": true,\n    \"RO_SCRIPT_PROJECT_CONTENT\": true,\n    \"RO_SCRIPT_DEPLOYMENTS\": true,\n    \"RO_SCRIPT_VERSIONS\": true,\n\n    \"RO_GITHUB_REPOS\": true,\n    \"RO_GITHUB_REPO_DETAIL\": true,\n    \"RO_GITHUB_WORKFLOW_RUNS\": true\n  };\n\n  var READ_ONLY \u003d {\n    \"READ_MEMORY_LOG\": true,\n    \"READ_SNAPSHOT_ACTIVE\": true,\n    \"READ_HUB_STATUS\": true,\n    \"LIST_ACTIONS\": true,\n\n    // READ-only connectors (inspection)\n    \"RO_DRIVE_TREE\": true,\n    \"RO_DRIVE_FILE_META\": true,\n    \"RO_DRIVE_CHANGES\": true,\n\n    \"RO_SCRIPT_PROJECT_DETAIL\": true,\n    \"RO_SCRIPT_PROJECT_CONTENT\": true,\n    \"RO_SCRIPT_DEPLOYMENTS\": true,\n    \"RO_SCRIPT_VERSIONS\": true,\n\n    \"RO_GITHUB_REPOS\": true,\n    \"RO_GITHUB_REPO_DETAIL\": true,\n    \"RO_GITHUB_WORKFLOW_RUNS\": true\n  };\n\n  function dispatch(req) {\n    const action \u003d String(req.action || \"\");\n    const payload \u003d req.payload || {};\n    const confirm \u003d (req.confirm \u003d\u003d\u003d true);\n    const requestId \u003d String(req.request_id || \"unknown\");\n    const mode \u003d IAPF_AUTH.getApiMode_();\n    const role \u003d (req \u0026\u0026 req._auth \u0026\u0026 req._auth.role) ? String(req._auth.role) : \"OPERATOR\";\n\n    if (!ALLOWLIST[action]) {\n      return build_(false, true, requestId, \"API_ACTION_REFUSED\", {\n        request_id: requestId,\n        action: action,\n        reason: \"Action not allowed\"\n      }, {\n        ok: false,\n        mode: mode,\n        request_id: requestId,\n        dry_run: true,\n        errors: [{ code: \"ACTION_NOT_ALLOWED\", message: \"Action not allowed\" }]\n      });\n    }\n\n    // READ-only: execute immediately (auth already done at API layer), still logged.\n    if (READ_ONLY[action]) {\n      const out \u003d execute_(action, payload, { auth: (req \u0026\u0026 req._auth) ? req._auth : {} });\n      return build_(true, false, requestId, \"API_READ_OK\", {\n        request_id: requestId,\n        action: action,\n        role: role\n      }, {\n        ok: true,\n        mode: mode,\n        request_id: requestId,\n        dry_run: false,\n        result: out\n      });\n    }\n\n    // WRITE actions are restricted to OPERATOR role\n    if (role !\u003d\u003d \"OPERATOR\") {\n      return build_(false, true, requestId, \"API_ROLE_REFUSED\", {\n        request_id: requestId,\n        action: action,\n        role: role,\n        reason: \"Role not allowed for write actions\"\n      }, {\n        ok: false,\n        mode: mode,\n        request_id: requestId,\n        dry_run: true,\n        errors: [{ code: \"ROLE_NOT_ALLOWED\", message: \"Role not allowed for write actions\" }]\n      });\n    }\n\n    // Build a plan (dry-run) for every WRITE action\n    const plan \u003d planFor_(action, payload);\n\n    if (!confirm) {\n      const confirmToken \u003d IAPF_AUTH.mintConfirmToken(plan);\n      return build_(true, true, requestId, \"API_DRY_RUN_PLAN\", {\n        request_id: requestId,\n        action: action,\n        plan: plan\n      }, {\n        ok: true,\n        mode: mode,\n        request_id: requestId,\n        dry_run: true,\n        confirm_token: confirmToken,\n        result: { plan: plan }\n      });\n    }\n\n    // confirm\u003dtrue requires confirm_token and verification\n    const ver \u003d IAPF_AUTH.verifyAndConsumeConfirmToken(String(req.confirm_token || \"\"), plan);\n    if (!ver.ok) {\n      return build_(false, true, requestId, \"API_CONFIRM_REFUSED\", {\n        request_id: requestId,\n        action: action,\n        reason: ver.reason\n      }, {\n        ok: false,\n        mode: mode,\n        request_id: requestId,\n        dry_run: true,\n        errors: [{ code: \"CONFIRM_REFUSED\", message: ver.reason }]\n      });\n    }\n\n    // Execute now (controlled)\n    const exec \u003d execute_(action, payload, { auth: (req \u0026\u0026 req._auth) ? req._auth : {} });\n\n    return build_(true, false, requestId, \"API_EXECUTED\", {\n      request_id: requestId,\n      action: action,\n      execution: exec\n    }, {\n      ok: true,\n      mode: mode,\n      request_id: requestId,\n      dry_run: false,\n      result: exec\n    });\n  }\n\n  function planFor_(action, payload) {\n    switch (action) {\n      case \"INITIALIZE_DAY\":\n        return { action: action, will_call: \"MCP_IMPL_initializeDay\", side_effects: [\"writes: HUB day state\", \"writes: MEMORY_LOG\"] };\n      case \"CLOSE_DAY\":\n        return { action: action, will_call: \"MCP_IMPL_closeDay\", side_effects: [\"writes: HUB day state\", \"writes: MEMORY_LOG\"] };\n      case \"GENERATE_SNAPSHOT\":\n        return { action: action, will_call: \"IAPF_generateSnapshot\", side_effects: [\"writes: Drive snapshot\", \"writes: SNAPSHOT_ACTIVE\"] };\n      case \"APPEND_MEMORY_ENTRY\":\n        return { action: action, will_call: \"IAPF_appendMemoryEntry_\", side_effects: [\"writes: MEMORY_LOG\"], input: sanitizeMemoryPayload_(payload) };\n      case \"GLOBAL_AUDIT\":\n        return { action: action, will_call: \"MCP_IMPL_globalAudit\", side_effects: [\"reads: all hub tabs\", \"writes: audit output tabs\"] };\n      case \"EXPORT_HUB\":\n        return { action: action, will_call: \"MCP_EXPORT_exportHubZipAndSheet\", side_effects: [\"writes: Drive export ZIP+XLSX\"] };\n      default:\n        return { action: action, will_call: \"UNKNOWN\" };\n    }\n  }\n\n  function execute_(action, payload, ctx) {\n    ctx \u003d ctx || {};\n    switch (action) {\n\n      // WRITE actions\n      case \"INITIALIZE_DAY\":\n        return { action: action, output: MCP_IMPL_initializeDay() };\n      case \"CLOSE_DAY\":\n        return { action: action, output: MCP_IMPL_closeDay() };\n      case \"GENERATE_SNAPSHOT\":\n        return { action: action, output: IAPF_generateSnapshot() };\n      case \"APPEND_MEMORY_ENTRY\": {\n        var p \u003d sanitizeMemoryPayload_(payload);\n        // Use the canonical writer in your HUB (supports positional \u0026 object)\n        if (typeof IAPF_appendMemoryEntry_ \u003d\u003d\u003d \"function\") {\n          IAPF_appendMemoryEntry_(p.type, p.title, p.details, { source: p.source, tags: p.tags, author: p.author, ts_iso: p.ts_iso });\n        } else if (typeof IAPF_appendMemoryEntry \u003d\u003d\u003d \"function\") {\n          IAPF_appendMemoryEntry(p.ts_iso, p.type, p.title, p.details, p.author, p.source, p.tags);\n        } else {\n          throw new Error(\"No memory writer found (IAPF_appendMemoryEntry_ / IAPF_appendMemoryEntry)\");\n        }\n        return { action: action, output: \"MEMORY_LOG_APPENDED\" };\n      }\n      case \"GLOBAL_AUDIT\":\n        return { action: action, output: MCP_IMPL_globalAudit() };\n      case \"EXPORT_HUB\":\n        return { action: action, output: MCP_EXPORT_exportHubZipAndSheet() };\n\n      // READ-only actions\n      case \"LIST_ACTIONS\":\n        return {\n          allowlist: Object.keys(ALLOWLIST).sort(),\n          read_only: Object.keys(READ_ONLY).sort(),\n          roles: [\"OPERATOR\", \"AUDITOR\"]\n        };\n\n      case \"READ_MEMORY_LOG\":\n        return readMemoryLog_(payload);\n\n      case \"READ_SNAPSHOT_ACTIVE\":\n        return readSnapshotActive_(payload);\n\n      case \"READ_HUB_STATUS\":\n        return readHubStatus_();\n\n      // CONNECTORS ‚Äî Drive\n      case \"RO_DRIVE_TREE\":\n        return (typeof IAPF_RO_driveTree_ \u003d\u003d\u003d \"function\") ? IAPF_RO_driveTree_(payload) : { error: \"Missing IAPF_RO_driveTree_\" };\n      case \"RO_DRIVE_FILE_META\":\n        return (typeof IAPF_RO_driveFileMeta_ \u003d\u003d\u003d \"function\") ? IAPF_RO_driveFileMeta_(payload, (ctx \u0026\u0026 ctx.auth) ? ctx.auth : {}) : { error: \"Missing IAPF_RO_driveFileMeta_\" };\n      case \"RO_DRIVE_CHANGES\":\n        return (typeof IAPF_RO_driveChanges_ \u003d\u003d\u003d \"function\") ? IAPF_RO_driveChanges_(payload) : { error: \"Missing IAPF_RO_driveChanges_\" };\n\n      // CONNECTORS ‚Äî Apps Script\n      case \"RO_SCRIPT_PROJECT_DETAIL\":\n        return (typeof IAPF_RO_scriptProjectDetail_ \u003d\u003d\u003d \"function\") ? IAPF_RO_scriptProjectDetail_(payload) : { error: \"Missing IAPF_RO_scriptProjectDetail_\" };\n      case \"RO_SCRIPT_PROJECT_CONTENT\":\n        return (typeof IAPF_RO_scriptProjectContent_ \u003d\u003d\u003d \"function\") ? IAPF_RO_scriptProjectContent_(payload) : { error: \"Missing IAPF_RO_scriptProjectContent_\" };\n      case \"RO_SCRIPT_DEPLOYMENTS\":\n        return (typeof IAPF_RO_scriptDeployments_ \u003d\u003d\u003d \"function\") ? IAPF_RO_scriptDeployments_(payload) : { error: \"Missing IAPF_RO_scriptDeployments_\" };\n      case \"RO_SCRIPT_VERSIONS\":\n        return (typeof IAPF_RO_scriptVersions_ \u003d\u003d\u003d \"function\") ? IAPF_RO_scriptVersions_(payload) : { error: \"Missing IAPF_RO_scriptVersions_\" };\n\n      // CONNECTORS ‚Äî GitHub\n      case \"RO_GITHUB_REPOS\":\n        return (typeof IAPF_RO_githubRepos_ \u003d\u003d\u003d \"function\") ? IAPF_RO_githubRepos_(payload) : { error: \"Missing IAPF_RO_githubRepos_\" };\n      case \"RO_GITHUB_REPO_DETAIL\":\n        return (typeof IAPF_RO_githubRepoDetail_ \u003d\u003d\u003d \"function\") ? IAPF_RO_githubRepoDetail_(payload) : { error: \"Missing IAPF_RO_githubRepoDetail_\" };\n      case \"RO_GITHUB_WORKFLOW_RUNS\":\n        return (typeof IAPF_RO_githubWorkflowRuns_ \u003d\u003d\u003d \"function\") ? IAPF_RO_githubWorkflowRuns_(payload) : { error: \"Missing IAPF_RO_githubWorkflowRuns_\" };\n\n      default:\n        throw new Error(\"Action not executable: \" + action);\n    }\n  }\n\n  function readMemoryLog_(payload) {\n    var p \u003d payload || {};\n    // Backward compatible paging:\n    // - legacy: { limit, offset }\n    // - new:    { page_size, cursor }\n    var limit \u003d clamp_(Number(p.page_size || p.limit || 50), 1, 200);\n    var offset \u003d Math.max(0, Number(p.offset || 0));\n    if (p.cursor) {\n      var decoded \u003d decodeCursorOffset_(String(p.cursor || \"\"));\n      if (!isNaN(decoded)) offset \u003d Math.max(0, decoded);\n    }\n    var reverse \u003d (p.reverse !\u003d\u003d false); // default true\n\n    var sh \u003d getSheetByKey_(\"MEMORY_LOG\");\n    var lastRow \u003d sh.getLastRow();\n    if (lastRow \u003c 2) {\n      return { rows: [], count: 0, limit: limit, offset: offset, reverse: reverse };\n    }\n\n    // Read all rows then slice (safe enough; capped by limit+offset, but we keep simple \u0026 stable)\n    var data \u003d sh.getRange(2, 1, lastRow - 1, 7).getValues();\n    if (reverse) data.reverse();\n\n    var sliced \u003d data.slice(offset, offset + limit);\n\n    var rows \u003d sliced.map(function (r) {\n      return {\n        ts_iso: String(r[0] || \"\"),\n        type: String(r[1] || \"\"),\n        title: String(r[2] || \"\"),\n        details: String(r[3] || \"\"),\n        author: String(r[4] || \"\"),\n        source: String(r[5] || \"\"),\n        tags: String(r[6] || \"\")\n      };\n    });\n\n    var nextOffset \u003d offset + rows.length;\n    var nextCursor \u003d (nextOffset \u003c data.length) ? encodeCursorOffset_(nextOffset) : \"\";\n\n    return {\n      rows: rows,\n      count: data.length,\n      limit: limit,\n      page_size: limit,\n      offset: offset,\n      reverse: reverse,\n      next_cursor: nextCursor\n    };\n  }\n\n  function encodeCursorOffset_(offset) {\n    try {\n      var json \u003d JSON.stringify({ o: Number(offset || 0) });\n      return Utilities.base64EncodeWebSafe(json);\n    } catch (e) {\n      return \"\";\n    }\n  }\n\n  function decodeCursorOffset_(cursor) {\n    try {\n      var json \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(cursor)).getDataAsString();\n      var obj \u003d JSON.parse(json || \"{}\");\n      return Number(obj.o || 0);\n    } catch (e) {\n      return NaN;\n    }\n  }\n\n  function readSnapshotActive_(payload) {\n    var sh \u003d getSheetByKey_(\"SNAPSHOT_ACTIVE\");\n    var lastRow \u003d sh.getLastRow();\n    var lastCol \u003d sh.getLastColumn();\n    if (lastRow \u003c 1 || lastCol \u003c 1) return { values: [] };\n\n    var maxRows \u003d clamp_(Number((payload || {}).max_rows || 20), 1, 200);\n    var maxCols \u003d clamp_(Number((payload || {}).max_cols || 10), 1, 50);\n\n    var r \u003d Math.min(lastRow, maxRows);\n    var c \u003d Math.min(lastCol, maxCols);\n\n    var values \u003d sh.getRange(1, 1, r, c).getValues();\n    return { values: values, rows: r, cols: c };\n  }\n\n  function readHubStatus_() {\n    var keys \u003d [\"MEMORY_LOG\", \"SNAPSHOT_ACTIVE\", \"DEPENDANCES_SCRIPTS\", \"CARTOGRAPHIE_APPELS\", \"REGLES_DE_GOUVERNANCE\", \"RISKS\", \"CONFLITS_DETECTES\"];\n    var out \u003d {};\n    keys.forEach(function (k) {\n      try {\n        var sh \u003d getSheetByKey_(k);\n        out[k] \u003d { ok: true, name: sh.getName() };\n      } catch (e) {\n        out[k] \u003d { ok: false, error: String(e \u0026\u0026 e.message ? e.message : e) };\n      }\n    });\n    return out;\n  }\n\n  function getSheetByKey_(key) {\n    if (typeof IAPF_SHEETS !\u003d\u003d \"undefined\" \u0026\u0026 IAPF_SHEETS \u0026\u0026 typeof IAPF_SHEETS.getSheet_ \u003d\u003d\u003d \"function\") {\n      return IAPF_SHEETS.getSheet_(key);\n    }\n    // fallback: direct name\n    var ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    var sh \u003d ss.getSheetByName(String(key));\n    if (!sh) throw new Error(\"Sheet not found: \" + key);\n    return sh;\n  }\n\n  function clamp_(n, min, max) {\n    if (isNaN(n)) return min;\n    return Math.max(min, Math.min(max, n));\n  }\n\n  function sanitizeMemoryPayload_(payload) {\n    var p \u003d payload || {};\n    return {\n      ts_iso: String(p.ts_iso || new Date().toISOString()),\n      type: String(p.type || \"CONSTAT\"),\n      title: String(p.title || \"API_ENTRY\"),\n      details: String(p.details || \"{}\"),\n      author: String(p.author || (Session.getActiveUser().getEmail() || \"system\")),\n      source: String(p.source || \"API\"),\n      tags: String(p.tags || \"IAPF;MCP;API\")\n    };\n  }\n\n  function build_(ok, dryRun, requestId, logTitle, logDetails, response) {\n    return {\n      ok: ok,\n      dry_run: dryRun,\n      log_title: logTitle,\n      log_details: logDetails,\n      response: response\n    };\n  }\n\n  return {\n    dispatch: dispatch\n  };\n\n})();\n"},{"id":"049d59ce-aad8-40e6-8be2-6e398f082b7e","name":"G13_READONLY_CONNECTORS","type":"server_js","source":"/**\n * G13_READONLY_CONNECTORS.gs\n *\n * READ-ONLY Connectors for inspection (Apps Script / Drive / GitHub).\n * Goal: enable MCP to audit environments without external console.\n *\n * Governance:\n * - No destructive operation.\n * - Pagination via cursor tokens.\n * - Minimal payloads by default (avoid giant responses).\n * - Secrets NEVER returned.\n */\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  Helpers\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction IAPF_RO_getSetting_(key) {\n  try {\n    if (typeof IAPF_getConfig_ \u003d\u003d\u003d \"function\") return String(IAPF_getConfig_(String(key)) || \"\");\n  } catch (e) {}\n\n  // Fallback: SETTINGS sheet (col A\u003dkey, col B\u003dvalue)\n  try {\n    var ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    var sh \u003d ss.getSheetByName(\"SETTINGS\");\n    if (!sh) return \"\";\n    var last \u003d sh.getLastRow();\n    if (last \u003c 2) return \"\";\n    var data \u003d sh.getRange(2, 1, last - 1, 2).getValues();\n    for (var i \u003d 0; i \u003c data.length; i++) {\n      if (String(data[i][0] || \"\").trim() \u003d\u003d\u003d String(key).trim()) {\n        return String(data[i][1] || \"\").trim();\n      }\n    }\n  } catch (e2) {}\n\n  return \"\";\n}\n\nfunction IAPF_RO_clamp_(n, min, max) {\n  n \u003d Number(n);\n  if (isNaN(n)) n \u003d min;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction IAPF_RO_encodeCursor_(obj) {\n  try {\n    return Utilities.base64EncodeWebSafe(JSON.stringify(obj || {}));\n  } catch (e) {\n    return \"\";\n  }\n}\n\nfunction IAPF_RO_decodeCursor_(cursor) {\n  try {\n    if (!cursor) return null;\n    var json \u003d Utilities.newBlob(Utilities.base64DecodeWebSafe(String(cursor))).getDataAsString();\n    return JSON.parse(json || \"{}\");\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction IAPF_RO_sha256_(text) {\n  try {\n    var bytes \u003d Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, String(text || \"\"), Utilities.Charset.UTF_8);\n    return bytes.map(function (b) {\n      var v \u003d (b \u003c 0) ? b + 256 : b;\n      var h \u003d v.toString(16);\n      return h.length \u003d\u003d\u003d 1 ? \"0\" + h : h;\n    }).join(\"\");\n  } catch (e) {\n    return \"\";\n  }\n}\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  Drive\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction IAPF_RO_driveListChildren_(parentId, pageToken, pageSize) {\n  var args \u003d {\n    q: \"\u0027\" + String(parentId) + \"\u0027 in parents and trashed \u003d false\",\n    pageSize: IAPF_RO_clamp_(pageSize || 100, 1, 200),\n    fields: \"nextPageToken,files(id,name,mimeType,parents,modifiedTime,createdTime,size,md5Checksum,webViewLink,trashed)\"\n  };\n  if (pageToken) args.pageToken \u003d String(pageToken);\n\n  // Advanced Drive service (Drive API v3) is enabled in appsscript.json\n  return Drive.Files.list(args);\n}\n\nfunction IAPF_RO_driveTree_(payload) {\n  var p \u003d payload || {};\n\n  // Defaults grounded in existing SETTINGS\n  var rootId \u003d String(p.root_id || IAPF_RO_getSetting_(\"memory_root_folder_id\") || \"\");\n  if (!rootId) {\n    return { ok: false, error: \"Missing root_id and SETTINGS.memory_root_folder_id\" };\n  }\n\n  var maxDepth \u003d IAPF_RO_clamp_(p.max_depth || 2, 0, 10);\n  var maxItems \u003d IAPF_RO_clamp_(p.max_items || 200, 1, 500);\n  var pageSize \u003d IAPF_RO_clamp_(p.page_size || 100, 1, 200);\n\n  // Cursor state\n  // { q: [{id,depth}], idx, pageToken }\n  var state \u003d IAPF_RO_decodeCursor_(p.cursor) || { q: [{ id: rootId, depth: 0 }], idx: 0, pageToken: \"\" };\n  if (!state.q || !state.q.length) state \u003d { q: [{ id: rootId, depth: 0 }], idx: 0, pageToken: \"\" };\n\n  var out \u003d [];\n  var safety \u003d 0;\n\n  while (out.length \u003c maxItems \u0026\u0026 state.idx \u003c state.q.length \u0026\u0026 safety \u003c 1000) {\n    safety++;\n\n    var node \u003d state.q[state.idx];\n    var parentId \u003d String(node.id);\n    var depth \u003d Number(node.depth || 0);\n\n    // Always list children for current node\n    var resp \u003d IAPF_RO_driveListChildren_(parentId, state.pageToken || \"\", pageSize);\n    var files \u003d (resp \u0026\u0026 resp.files) ? resp.files : [];\n\n    files.forEach(function (f) {\n      var mime \u003d String(f.mimeType || \"\");\n      var isFolder \u003d (mime \u003d\u003d\u003d \"application/vnd.google-apps.folder\");\n\n      out.push({\n        id: String(f.id || \"\"),\n        name: String(f.name || \"\"),\n        mimeType: mime,\n        isFolder: isFolder,\n        parentId: parentId,\n        depth: depth + 1,\n        modifiedTime: String(f.modifiedTime || \"\"),\n        createdTime: String(f.createdTime || \"\"),\n        size: (f.size !\u003d\u003d undefined \u0026\u0026 f.size !\u003d\u003d null) ? String(f.size) : \"\",\n        md5Checksum: String(f.md5Checksum || \"\"),\n        webViewLink: String(f.webViewLink || \"\"),\n        trashed: !!f.trashed\n      });\n\n      // Expand queue (folders only) within maxDepth\n      if (isFolder \u0026\u0026 (depth + 1) \u003c\u003d maxDepth) {\n        state.q.push({ id: String(f.id), depth: depth + 1 });\n      }\n    });\n\n    // Pagination handling for current folder\n    if (resp \u0026\u0026 resp.nextPageToken) {\n      state.pageToken \u003d String(resp.nextPageToken);\n    } else {\n      state.idx \u003d Number(state.idx || 0) + 1;\n      state.pageToken \u003d \"\";\n    }\n\n    if (out.length \u003e\u003d maxItems) break;\n  }\n\n  var nextCursor \u003d (state.idx \u003c state.q.length) ? IAPF_RO_encodeCursor_(state) : \"\";\n\n  return {\n    ok: true,\n    root_id: rootId,\n    max_depth: maxDepth,\n    returned: out.length,\n    items: out,\n    next_cursor: nextCursor\n  };\n}\n\nfunction IAPF_RO_driveFileMeta_(payload, auth) {\n  var p \u003d payload || {};\n  var role \u003d (auth \u0026\u0026 auth.role) ? String(auth.role) : \"OPERATOR\";\n\n  var fileId \u003d String(p.file_id || \"\");\n  if (!fileId) return { ok: false, error: \"Missing file_id\" };\n\n  var fields \u003d \"id,name,mimeType,parents,owners,createdTime,modifiedTime,size,md5Checksum,webViewLink,iconLink,trashed\";\n  var meta \u003d Drive.Files.get(fileId, { fields: fields });\n\n  var out \u003d {\n    id: String(meta.id || \"\"),\n    name: String(meta.name || \"\"),\n    mimeType: String(meta.mimeType || \"\"),\n    parents: meta.parents || [],\n    createdTime: String(meta.createdTime || \"\"),\n    modifiedTime: String(meta.modifiedTime || \"\"),\n    size: (meta.size !\u003d\u003d undefined \u0026\u0026 meta.size !\u003d\u003d null) ? String(meta.size) : \"\",\n    md5Checksum: String(meta.md5Checksum || \"\"),\n    webViewLink: String(meta.webViewLink || \"\"),\n    iconLink: String(meta.iconLink || \"\"),\n    trashed: !!meta.trashed\n  };\n\n  // Owners: redact email addresses by default (AUDITOR always redacted)\n  var owners \u003d meta.owners || [];\n  out.owners \u003d owners.map(function (o) {\n    return {\n      displayName: String(o.displayName || \"\"),\n      permissionId: String(o.permissionId || \"\"),\n      // emailAddress only for OPERATOR if explicitly asked\n      emailAddress: (role \u003d\u003d\u003d \"OPERATOR\" \u0026\u0026 p.include_emails \u003d\u003d\u003d true) ? String(o.emailAddress || \"\") : \"\"\n    };\n  });\n\n  // Optional permissions list (redacted by default)\n  if (p.include_permissions \u003d\u003d\u003d true) {\n    try {\n      var permResp \u003d Drive.Permissions.list(fileId, {\n        fields: \"permissions(id,type,role,domain,allowFileDiscovery,deleted,displayName,emailAddress)\"\n      });\n      var perms \u003d (permResp \u0026\u0026 permResp.permissions) ? permResp.permissions : [];\n\n      out.permissions \u003d perms.map(function (x) {\n        return {\n          id: String(x.id || \"\"),\n          type: String(x.type || \"\"),\n          role: String(x.role || \"\"),\n          domain: String(x.domain || \"\"),\n          allowFileDiscovery: !!x.allowFileDiscovery,\n          deleted: !!x.deleted,\n          displayName: String(x.displayName || \"\"),\n          emailAddress: (role \u003d\u003d\u003d \"OPERATOR\" \u0026\u0026 p.include_emails \u003d\u003d\u003d true) ? String(x.emailAddress || \"\") : \"\"\n        };\n      });\n    } catch (e) {\n      out.permissions_error \u003d String(e \u0026\u0026 e.message ? e.message : e);\n    }\n  }\n\n  return { ok: true, file: out };\n}\n\nfunction IAPF_RO_driveChanges_(payload) {\n  var p \u003d payload || {};\n  var maxItems \u003d IAPF_RO_clamp_(p.max_items || 100, 1, 200);\n\n  // Cursor state: { pageToken, startPageToken }\n  var state \u003d IAPF_RO_decodeCursor_(p.cursor) || {};\n\n  var startPageToken \u003d String(p.start_page_token || state.startPageToken || \"\");\n  var pageToken \u003d String(p.page_token || state.pageToken || \"\");\n\n  if (!pageToken) {\n    if (!startPageToken) {\n      // Create a new startPageToken\n      var spt \u003d Drive.Changes.getStartPageToken();\n      startPageToken \u003d String(spt.startPageToken || \"\");\n    }\n    pageToken \u003d startPageToken;\n  }\n\n  var resp \u003d Drive.Changes.list(pageToken, {\n    pageSize: maxItems,\n    fields: \"newStartPageToken,nextPageToken,changes(fileId,time,removed,file(id,name,mimeType,parents,modifiedTime,trashed))\"\n  });\n\n  var changes \u003d (resp \u0026\u0026 resp.changes) ? resp.changes : [];\n  var items \u003d changes.map(function (c) {\n    var f \u003d c.file || {};\n    return {\n      fileId: String(c.fileId || \"\"),\n      time: String(c.time || \"\"),\n      removed: !!c.removed,\n      file: f ? {\n        id: String(f.id || \"\"),\n        name: String(f.name || \"\"),\n        mimeType: String(f.mimeType || \"\"),\n        parents: f.parents || [],\n        modifiedTime: String(f.modifiedTime || \"\"),\n        trashed: !!f.trashed\n      } : null\n    };\n  });\n\n  var next \u003d \"\";\n  if (resp \u0026\u0026 resp.nextPageToken) {\n    next \u003d IAPF_RO_encodeCursor_({\n      startPageToken: startPageToken,\n      pageToken: String(resp.nextPageToken)\n    });\n  }\n\n  return {\n    ok: true,\n    start_page_token: startPageToken,\n    new_start_page_token: String(resp \u0026\u0026 resp.newStartPageToken ? resp.newStartPageToken : \"\"),\n    returned: items.length,\n    changes: items,\n    next_cursor: next\n  };\n}\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  Apps Script (script.googleapis.com)\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction IAPF_RO_scriptApiGet_(path, query) {\n  var base \u003d \"https://script.googleapis.com/v1\";\n  var url \u003d base + String(path || \"\");\n\n  var q \u003d query || {};\n  var parts \u003d [];\n  Object.keys(q).forEach(function (k) {\n    if (q[k] \u003d\u003d\u003d undefined || q[k] \u003d\u003d\u003d null || q[k] \u003d\u003d\u003d \"\") return;\n    parts.push(encodeURIComponent(k) + \"\u003d\" + encodeURIComponent(String(q[k])));\n  });\n  if (parts.length) url +\u003d (url.indexOf(\"?\") \u003d\u003d\u003d -1 ? \"?\" : \"\u0026\") + parts.join(\"\u0026\");\n\n  var token \u003d ScriptApp.getOAuthToken();\n  var resp \u003d UrlFetchApp.fetch(url, {\n    method: \"get\",\n    muteHttpExceptions: true,\n    headers: {\n      Authorization: \"Bearer \" + token\n    }\n  });\n\n  var status \u003d resp.getResponseCode();\n  var text \u003d resp.getContentText() || \"\";\n  if (status \u003c 200 || status \u003e\u003d 300) {\n    return { ok: false, http: status, error: text.substring(0, 2000) };\n  }\n\n  try {\n    return { ok: true, data: JSON.parse(text || \"{}\") };\n  } catch (e) {\n    return { ok: true, data: { raw: text } };\n  }\n}\n\nfunction IAPF_RO_resolveScriptId_(payload) {\n  var p \u003d payload || {};\n  var target \u003d String(p.target || \"HUB\").toUpperCase();\n\n  if (p.script_id) return String(p.script_id);\n\n  if (target \u003d\u003d\u003d \"HUB\") {\n    return ScriptApp.getScriptId();\n  }\n\n  if (target \u003d\u003d\u003d \"BOX2026\") {\n    var id \u003d IAPF_RO_getSetting_(\"box2026_script_id\");\n    return String(id || \"\");\n  }\n\n  return \"\";\n}\n\nfunction IAPF_RO_scriptProjectDetail_(payload) {\n  var scriptId \u003d IAPF_RO_resolveScriptId_(payload);\n  if (!scriptId) return { ok: false, error: \"Missing script_id and cannot resolve target\" };\n\n  var res \u003d IAPF_RO_scriptApiGet_(\"/projects/\" + encodeURIComponent(scriptId), {});\n  if (!res.ok) return res;\n\n  // Return only stable fields\n  var d \u003d res.data || {};\n  return {\n    ok: true,\n    script_id: scriptId,\n    title: String(d.title || \"\"),\n    parentId: String(d.parentId || \"\"),\n    updateTime: String(d.updateTime || \"\"),\n    createTime: String(d.createTime || \"\")\n  };\n}\n\nfunction IAPF_RO_scriptProjectContent_(payload) {\n  var p \u003d payload || {};\n  var scriptId \u003d IAPF_RO_resolveScriptId_(p);\n  if (!scriptId) return { ok: false, error: \"Missing script_id and cannot resolve target\" };\n  var maxFiles \u003d IAPF_RO_clamp_(p.max_files || 200, 1, 500);\n\n  var res \u003d IAPF_RO_scriptApiGet_(\"/projects/\" + encodeURIComponent(scriptId) + \"/content\", {});\n  if (!res.ok) return res;\n\n  var files \u003d (res.data \u0026\u0026 res.data.files) ? res.data.files : [];\n  files \u003d files.slice(0, maxFiles);\n\n  var outFiles \u003d files.map(function (f) {\n    var name \u003d String(f.name || \"\");\n    var type \u003d String(f.type || \"\");\n    var source \u003d (f.source !\u003d\u003d undefined \u0026\u0026 f.source !\u003d\u003d null) ? String(f.source) : \"\";\n    var hash \u003d IAPF_RO_sha256_(source);\n\n    return {\n      name: name,\n      type: type,\n      sha256: hash\n    };\n  });\n\n  return {\n    ok: true,\n    script_id: scriptId,\n    returned: outFiles.length,\n    files: outFiles\n  };\n}\n\nfunction IAPF_RO_scriptDeployments_(payload) {\n  var p \u003d payload || {};\n  var scriptId \u003d IAPF_RO_resolveScriptId_(p);\n  if (!scriptId) return { ok: false, error: \"Missing script_id and cannot resolve target\" };\n\n  var pageSize \u003d IAPF_RO_clamp_(p.page_size || 50, 1, 100);\n  var cursor \u003d IAPF_RO_decodeCursor_(p.cursor) || {};\n  var pageToken \u003d String(p.page_token || cursor.pageToken || \"\");\n\n  var res \u003d IAPF_RO_scriptApiGet_(\"/projects/\" + encodeURIComponent(scriptId) + \"/deployments\", {\n    pageSize: pageSize,\n    pageToken: pageToken\n  });\n  if (!res.ok) return res;\n\n  var d \u003d res.data || {};\n  var deployments \u003d (d.deployments || []).map(function (x) {\n    return {\n      deploymentId: String(x.deploymentId || \"\"),\n      updateTime: String(x.updateTime || \"\"),\n      // manifestFileName is stable and helps debug without leaking config\n      manifestFileName: (x.deploymentConfig \u0026\u0026 x.deploymentConfig.manifestFileName) ? String(x.deploymentConfig.manifestFileName) : \"\",\n      versionNumber: (x.deploymentConfig \u0026\u0026 x.deploymentConfig.versionNumber !\u003d\u003d undefined) ? String(x.deploymentConfig.versionNumber) : \"\"\n    };\n  });\n\n  var next \u003d \"\";\n  if (d.nextPageToken) next \u003d IAPF_RO_encodeCursor_({ pageToken: String(d.nextPageToken) });\n\n  return {\n    ok: true,\n    script_id: scriptId,\n    returned: deployments.length,\n    deployments: deployments,\n    next_cursor: next\n  };\n}\n\nfunction IAPF_RO_scriptVersions_(payload) {\n  var p \u003d payload || {};\n  var scriptId \u003d IAPF_RO_resolveScriptId_(p);\n  if (!scriptId) return { ok: false, error: \"Missing script_id and cannot resolve target\" };\n\n  var pageSize \u003d IAPF_RO_clamp_(p.page_size || 50, 1, 100);\n  var cursor \u003d IAPF_RO_decodeCursor_(p.cursor) || {};\n  var pageToken \u003d String(p.page_token || cursor.pageToken || \"\");\n\n  var res \u003d IAPF_RO_scriptApiGet_(\"/projects/\" + encodeURIComponent(scriptId) + \"/versions\", {\n    pageSize: pageSize,\n    pageToken: pageToken\n  });\n  if (!res.ok) return res;\n\n  var d \u003d res.data || {};\n  var versions \u003d (d.versions || []).map(function (v) {\n    return {\n      versionNumber: (v.versionNumber !\u003d\u003d undefined) ? String(v.versionNumber) : \"\",\n      description: String(v.description || \"\"),\n      createTime: String(v.createTime || \"\")\n    };\n  });\n\n  var next \u003d \"\";\n  if (d.nextPageToken) next \u003d IAPF_RO_encodeCursor_({ pageToken: String(d.nextPageToken) });\n\n  return {\n    ok: true,\n    script_id: scriptId,\n    returned: versions.length,\n    versions: versions,\n    next_cursor: next\n  };\n}\n\n/** \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n *  GitHub (api.github.com)\n *  \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n\nfunction IAPF_RO_getGithubToken_() {\n  // Token MUST be stored in ScriptProperties (never in SHEET).\n  // Property name is explicit to avoid confusion.\n  var props \u003d PropertiesService.getScriptProperties();\n  return String(props.getProperty(\"IAPF_GITHUB_TOKEN\") || \"\");\n}\n\nfunction IAPF_RO_githubGet_(path, query) {\n  var token \u003d IAPF_RO_getGithubToken_();\n  if (!token) return { ok: false, error: \"Missing ScriptProperty IAPF_GITHUB_TOKEN\" };\n\n  var url \u003d \"https://api.github.com\" + String(path || \"\");\n  var q \u003d query || {};\n  var parts \u003d [];\n  Object.keys(q).forEach(function (k) {\n    if (q[k] \u003d\u003d\u003d undefined || q[k] \u003d\u003d\u003d null || q[k] \u003d\u003d\u003d \"\") return;\n    parts.push(encodeURIComponent(k) + \"\u003d\" + encodeURIComponent(String(q[k])));\n  });\n  if (parts.length) url +\u003d (url.indexOf(\"?\") \u003d\u003d\u003d -1 ? \"?\" : \"\u0026\") + parts.join(\"\u0026\");\n\n  var resp \u003d UrlFetchApp.fetch(url, {\n    method: \"get\",\n    muteHttpExceptions: true,\n    headers: {\n      Authorization: \"Bearer \" + token,\n      Accept: \"application/vnd.github+json\",\n      \"X-GitHub-Api-Version\": \"2022-11-28\"\n    }\n  });\n\n  var status \u003d resp.getResponseCode();\n  var text \u003d resp.getContentText() || \"\";\n\n  if (status \u003c 200 || status \u003e\u003d 300) {\n    // Never return full raw body (may include sensitive info). Keep compact.\n    return { ok: false, http: status, error: text.substring(0, 1200) };\n  }\n\n  try {\n    return { ok: true, data: JSON.parse(text || \"{}\") };\n  } catch (e) {\n    return { ok: true, data: { raw: text } };\n  }\n}\n\nfunction IAPF_RO_githubRepos_(payload) {\n  var p \u003d payload || {};\n  var pageSize \u003d IAPF_RO_clamp_(p.page_size || 50, 1, 100);\n\n  var cursor \u003d IAPF_RO_decodeCursor_(p.cursor) || {};\n  var page \u003d Number(p.page || cursor.page || 1);\n  if (isNaN(page) || page \u003c 1) page \u003d 1;\n\n  // Either org (preferred) or user\n  var org \u003d String(p.org || \"\").trim();\n  var user \u003d String(p.user || \"\").trim();\n\n  var path \u003d \"\";\n  if (org) path \u003d \"/orgs/\" + encodeURIComponent(org) + \"/repos\";\n  else if (user) path \u003d \"/users/\" + encodeURIComponent(user) + \"/repos\";\n  else return { ok: false, error: \"Missing org or user\" };\n\n  var res \u003d IAPF_RO_githubGet_(path, {\n    per_page: pageSize,\n    page: page,\n    sort: String(p.sort || \"pushed\")\n  });\n  if (!res.ok) return res;\n\n  var items \u003d (res.data || []).map(function (r) {\n    return {\n      id: (r.id !\u003d\u003d undefined) ? String(r.id) : \"\",\n      full_name: String(r.full_name || \"\"),\n      private: !!r.private,\n      default_branch: String(r.default_branch || \"\"),\n      pushed_at: String(r.pushed_at || \"\"),\n      updated_at: String(r.updated_at || \"\"),\n      html_url: String(r.html_url || \"\")\n    };\n  });\n\n  var next \u003d (items.length \u003d\u003d\u003d pageSize) ? IAPF_RO_encodeCursor_({ page: page + 1 }) : \"\";\n\n  return {\n    ok: true,\n    returned: items.length,\n    repos: items,\n    next_cursor: next\n  };\n}\n\nfunction IAPF_RO_githubRepoDetail_(payload) {\n  var p \u003d payload || {};\n  var owner \u003d String(p.owner || \"\").trim();\n  var repo \u003d String(p.repo || \"\").trim();\n  if (!owner || !repo) return { ok: false, error: \"Missing owner/repo\" };\n\n  var res \u003d IAPF_RO_githubGet_(\"/repos/\" + encodeURIComponent(owner) + \"/\" + encodeURIComponent(repo), {});\n  if (!res.ok) return res;\n\n  var r \u003d res.data || {};\n  return {\n    ok: true,\n    repo: {\n      id: (r.id !\u003d\u003d undefined) ? String(r.id) : \"\",\n      full_name: String(r.full_name || \"\"),\n      private: !!r.private,\n      default_branch: String(r.default_branch || \"\"),\n      description: String(r.description || \"\"),\n      pushed_at: String(r.pushed_at || \"\"),\n      updated_at: String(r.updated_at || \"\"),\n      html_url: String(r.html_url || \"\"),\n      open_issues_count: (r.open_issues_count !\u003d\u003d undefined) ? Number(r.open_issues_count) : 0,\n      forks_count: (r.forks_count !\u003d\u003d undefined) ? Number(r.forks_count) : 0,\n      stargazers_count: (r.stargazers_count !\u003d\u003d undefined) ? Number(r.stargazers_count) : 0\n    }\n  };\n}\n\nfunction IAPF_RO_githubWorkflowRuns_(payload) {\n  var p \u003d payload || {};\n  var owner \u003d String(p.owner || \"\").trim();\n  var repo \u003d String(p.repo || \"\").trim();\n  if (!owner || !repo) return { ok: false, error: \"Missing owner/repo\" };\n\n  var pageSize \u003d IAPF_RO_clamp_(p.page_size || 30, 1, 100);\n  var cursor \u003d IAPF_RO_decodeCursor_(p.cursor) || {};\n  var page \u003d Number(p.page || cursor.page || 1);\n  if (isNaN(page) || page \u003c 1) page \u003d 1;\n\n  var res \u003d IAPF_RO_githubGet_(\"/repos/\" + encodeURIComponent(owner) + \"/\" + encodeURIComponent(repo) + \"/actions/runs\", {\n    per_page: pageSize,\n    page: page,\n    status: String(p.status || \"\")\n  });\n  if (!res.ok) return res;\n\n  var d \u003d res.data || {};\n  var runs \u003d (d.workflow_runs || []).map(function (x) {\n    return {\n      id: (x.id !\u003d\u003d undefined) ? String(x.id) : \"\",\n      name: String(x.name || \"\"),\n      event: String(x.event || \"\"),\n      status: String(x.status || \"\"),\n      conclusion: String(x.conclusion || \"\"),\n      created_at: String(x.created_at || \"\"),\n      updated_at: String(x.updated_at || \"\"),\n      head_branch: String(x.head_branch || \"\"),\n      head_sha: String(x.head_sha || \"\"),\n      actor: x.actor ? { login: String(x.actor.login || \"\") } : null,\n      html_url: String(x.html_url || \"\")\n    };\n  });\n\n  var next \u003d (runs.length \u003d\u003d\u003d pageSize) ? IAPF_RO_encodeCursor_({ page: page + 1 }) : \"\";\n\n  return {\n    ok: true,\n    total_count: (d.total_count !\u003d\u003d undefined) ? Number(d.total_count) : 0,\n    returned: runs.length,\n    workflow_runs: runs,\n    next_cursor: next\n  };\n}\n"},{"id":"9c670a1e-4653-4e0d-9751-499d6daa557c","name":"G14_MCP_HTTP_CLIENT","type":"server_js","source":"/**\n * FILE: G09_MCP_HTTP_CLIENT.gs\n * PROJECT: IAPF MEMORY HUB V1\n * \n * Objectif:\n * - Client HTTP pour appeler le backend MCP Memory Proxy (Cloud Run)\n * - Pass-through strict des query params (e.g., ?limit\u003d)\n * - Remont√©e d√©taill√©e des erreurs (status_code + body + correlation_id)\n * - Support GET only (read-only audit mode)\n * \n * D√©pendances:\n * - SETTINGS: mcp_proxy_url, mcp_api_key\n */\n\nvar MCP_HTTP \u003d (function() {\n\n  /**\n   * Get base URL from SETTINGS (mcp_proxy_url)\n   * Example: \"https://mcp-memory-proxy-522732657254.us-central1.run.app\"\n   */\n  function _getBaseUrl_() {\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const sh \u003d ss.getSheetByName(\"SETTINGS\");\n    if (!sh) throw new Error(\"SETTINGS sheet not found\");\n    \n    const values \u003d sh.getDataRange().getValues();\n    for (let i \u003d 1; i \u003c values.length; i++) {\n      const key \u003d String(values[i][0] || \"\").trim();\n      if (key \u003d\u003d\u003d \"mcp_proxy_url\") {\n        const url \u003d String(values[i][1] || \"\").trim();\n        if (!url) throw new Error(\"SETTINGS: mcp_proxy_url is empty\");\n        return url;\n      }\n    }\n    throw new Error(\"SETTINGS: mcp_proxy_url not found\");\n  }\n\n  /**\n   * Get API key from SETTINGS (mcp_api_key)\n   * CRITICAL: This key is sensitive and should NEVER be logged\n   */\n  function _getApiKey_() {\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const sh \u003d ss.getSheetByName(\"SETTINGS\");\n    if (!sh) throw new Error(\"SETTINGS sheet not found\");\n    \n    const values \u003d sh.getDataRange().getValues();\n    for (let i \u003d 1; i \u003c values.length; i++) {\n      const key \u003d String(values[i][0] || \"\").trim();\n      if (key \u003d\u003d\u003d \"mcp_api_key\") {\n        const apiKey \u003d String(values[i][1] || \"\").trim();\n        if (!apiKey) throw new Error(\"SETTINGS: mcp_api_key is empty\");\n        return apiKey;\n      }\n    }\n    throw new Error(\"SETTINGS: mcp_api_key not found\");\n  }\n\n  /**\n   * Build URL with query parameters\n   * Ensures strict pass-through of all params\n   */\n  function _buildUrl_(path, queryParams) {\n    let url \u003d _getBaseUrl_() + path;\n    if (queryParams \u0026\u0026 Object.keys(queryParams).length \u003e 0) {\n      const params \u003d [];\n      for (const key in queryParams) {\n        if (queryParams.hasOwnProperty(key)) {\n          const value \u003d queryParams[key];\n          if (value !\u003d\u003d null \u0026\u0026 value !\u003d\u003d undefined) {\n            params.push(encodeURIComponent(key) + \"\u003d\" + encodeURIComponent(value));\n          }\n        }\n      }\n      if (params.length \u003e 0) {\n        url +\u003d \"?\" + params.join(\"\u0026\");\n      }\n    }\n    return url;\n  }\n\n  /**\n   * Execute HTTP GET request\n   * Returns: { ok: boolean, status: number, body: object|string, correlation_id: string|null, error: string|null }\n   */\n  function _httpGet_(path, queryParams, extraHeaders) {\n    const url \u003d _buildUrl_(path, queryParams);\n    const apiKey \u003d _getApiKey_();\n    \n    const headers \u003d {\n      \"X-API-Key\": apiKey,\n      \"Accept\": \"application/json\"\n    };\n    \n    if (extraHeaders) {\n      for (const key in extraHeaders) {\n        if (extraHeaders.hasOwnProperty(key)) {\n          headers[key] \u003d extraHeaders[key];\n        }\n      }\n    }\n\n    let response;\n    try {\n      response \u003d UrlFetchApp.fetch(url, {\n        method: \"get\",\n        headers: headers,\n        muteHttpExceptions: true\n      });\n    } catch (e) {\n      return {\n        ok: false,\n        status: 0,\n        body: null,\n        correlation_id: null,\n        error: \"Network error: \" + String(e.message || e)\n      };\n    }\n\n    const statusCode \u003d response.getResponseCode();\n    const contentText \u003d response.getContentText();\n    \n    let bodyObj \u003d null;\n    let correlationId \u003d null;\n    \n    try {\n      bodyObj \u003d JSON.parse(contentText);\n      if (bodyObj \u0026\u0026 bodyObj.correlation_id) {\n        correlationId \u003d bodyObj.correlation_id;\n      }\n    } catch (e) {\n      // Not JSON, keep as string\n      bodyObj \u003d contentText;\n    }\n\n    return {\n      ok: (statusCode \u003e\u003d 200 \u0026\u0026 statusCode \u003c 300),\n      status: statusCode,\n      body: bodyObj,\n      correlation_id: correlationId,\n      error: (statusCode \u003e\u003d 200 \u0026\u0026 statusCode \u003c 300) ? null : \"HTTP \" + statusCode\n    };\n  }\n\n  /**\n   * Public API: GET /infra/whoami\n   * Returns full response including cloud_run_revision, version, config.read_only_mode, etc.\n   */\n  function getInfraWhoami() {\n    return _httpGet_(\"/infra/whoami\", null, null);\n  }\n\n  /**\n   * Public API: GET /health\n   */\n  function getHealth() {\n    return _httpGet_(\"/health\", null, null);\n  }\n\n  /**\n   * Public API: GET /docs-json\n   */\n  function getDocsJson() {\n    return _httpGet_(\"/docs-json\", null, null);\n  }\n\n  /**\n   * Public API: GET /sheets/{sheet_name}\n   * queryParams can include: limit, offset, cursor, reverse\n   */\n  function getSheet(sheetName, queryParams) {\n    if (!sheetName) throw new Error(\"sheetName is required\");\n    return _httpGet_(\"/sheets/\" + encodeURIComponent(sheetName), queryParams, null);\n  }\n\n  /**\n   * Public API: GET /gpt/memory-log\n   * queryParams can include: limit, offset, cursor, reverse\n   */\n  function getGptMemoryLog(queryParams) {\n    return _httpGet_(\"/gpt/memory-log\", queryParams, null);\n  }\n\n  return {\n    getInfraWhoami: getInfraWhoami,\n    getHealth: getHealth,\n    getDocsJson: getDocsJson,\n    getSheet: getSheet,\n    getGptMemoryLog: getGptMemoryLog\n  };\n\n})();\n\n/**\n * \u003d\u003d\u003d\u003d\u003d COCKPIT UI ACTIONS \u003d\u003d\u003d\u003d\u003d\n * These functions are called from the menu (G01_UI_MENU.gs)\n */\n\nfunction MCP_COCKPIT_testConnection() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  try {\n    const result \u003d MCP_HTTP.getHealth();\n    \n    if (result.ok) {\n      const version \u003d result.body \u0026\u0026 result.body.version ? result.body.version : \"unknown\";\n      ui.alert(\n        \"MCP Proxy ‚Äî Connection OK\",\n        \"‚úÖ Backend health check passed\\n\\nVersion: \" + version + \"\\nStatus: \" + result.status,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\n        \"MCP Proxy ‚Äî Connection Error\",\n        \"‚ùå Health check failed\\n\\n\" +\n        \"Status: \" + result.status + \"\\n\" +\n        \"Error: \" + (result.error || \"unknown\") + \"\\n\\n\" +\n        \"Response:\\n\" + JSON.stringify(result.body, null, 2).slice(0, 500),\n        ui.ButtonSet.OK\n      );\n    }\n  } catch (e) {\n    ui.alert(\n      \"MCP Proxy ‚Äî Error\",\n      \"Exception: \" + String(e.message || e) + \"\\n\\n\" +\n      \"Check SETTINGS: mcp_proxy_url and mcp_api_key must be set.\",\n      ui.ButtonSet.OK\n    );\n  }\n}\n\nfunction MCP_COCKPIT_getWhoami() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  try {\n    const result \u003d MCP_HTTP.getInfraWhoami();\n    \n    if (result.ok) {\n      const data \u003d result.body;\n      const config \u003d data.config || {};\n      \n      const msg \u003d \n        \"‚úÖ GET /infra/whoami succeeded\\n\\n\" +\n        \"Project: \" + (data.project_id || \"N/A\") + \"\\n\" +\n        \"Region: \" + (data.region || \"N/A\") + \"\\n\" +\n        \"Service: \" + (data.cloud_run_service || \"N/A\") + \"\\n\" +\n        \"Revision: \" + (data.cloud_run_revision || \"N/A\") + \"\\n\" +\n        \"Version: \" + (data.version || \"N/A\") + \"\\n\\n\" +\n        \"Config:\\n\" +\n        \"  read_only_mode: \" + (config.read_only_mode || \"N/A\") + \"\\n\" +\n        \"  enable_actions: \" + (config.enable_actions || \"N/A\") + \"\\n\" +\n        \"  dry_run_mode: \" + (config.dry_run_mode || \"N/A\") + \"\\n\" +\n        \"  log_level: \" + (config.log_level || \"N/A\");\n      \n      ui.alert(\"MCP Proxy ‚Äî Infrastructure Info\", msg, ui.ButtonSet.OK);\n    } else {\n      ui.alert(\n        \"MCP Proxy ‚Äî Error\",\n        \"‚ùå GET /infra/whoami failed\\n\\n\" +\n        \"Status: \" + result.status + \"\\n\" +\n        \"Error: \" + (result.error || \"unknown\") + \"\\n\" +\n        \"Correlation ID: \" + (result.correlation_id || \"N/A\") + \"\\n\\n\" +\n        \"Response:\\n\" + JSON.stringify(result.body, null, 2).slice(0, 500),\n        ui.ButtonSet.OK\n      );\n    }\n  } catch (e) {\n    ui.alert(\n      \"MCP Proxy ‚Äî Error\",\n      \"Exception: \" + String(e.message || e),\n      ui.ButtonSet.OK\n    );\n  }\n}\n\nfunction MCP_COCKPIT_testPagination() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const response \u003d ui.alert(\n    \"MCP Proxy ‚Äî Test Pagination\",\n    \"This will test query params pass-through:\\n\\n\" +\n    \"‚Ä¢ GET /sheets/SETTINGS?limit\u003d1\\n\" +\n    \"‚Ä¢ GET /sheets/MEMORY_LOG?limit\u003d5\\n\" +\n    \"‚Ä¢ GET /sheets/DRIVE_INVENTORY?limit\u003d10\\n\\n\" +\n    \"Continue?\",\n    ui.ButtonSet.YES_NO\n  );\n  \n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP Proxy\", \"Test cancelled.\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const tests \u003d [\n      { sheet: \"SETTINGS\", limit: 1 },\n      { sheet: \"MEMORY_LOG\", limit: 5 },\n      { sheet: \"DRIVE_INVENTORY\", limit: 10 }\n    ];\n    \n    const results \u003d [];\n    \n    for (let i \u003d 0; i \u003c tests.length; i++) {\n      const test \u003d tests[i];\n      const result \u003d MCP_HTTP.getSheet(test.sheet, { limit: test.limit });\n      \n      if (result.ok) {\n        const rowCount \u003d result.body \u0026\u0026 result.body.row_count ? result.body.row_count : 0;\n        results.push(\"‚úÖ \" + test.sheet + \"?limit\u003d\" + test.limit + \" ‚Üí \" + rowCount + \" rows\");\n      } else {\n        results.push(\"‚ùå \" + test.sheet + \"?limit\u003d\" + test.limit + \" ‚Üí HTTP \" + result.status);\n      }\n    }\n    \n    ui.alert(\n      \"MCP Proxy ‚Äî Pagination Tests\",\n      results.join(\"\\n\"),\n      ui.ButtonSet.OK\n    );\n    \n  } catch (e) {\n    ui.alert(\n      \"MCP Proxy ‚Äî Error\",\n      \"Exception: \" + String(e.message || e),\n      ui.ButtonSet.OK\n    );\n  }\n}\n\nfunction MCP_COCKPIT_httpGetTool() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  // Prompt for path\n  const pathResponse \u003d ui.prompt(\n    \"MCP Proxy ‚Äî HTTP GET Tool\",\n    \"Enter the endpoint path (e.g., /infra/whoami, /sheets/SETTINGS):\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (pathResponse.getSelectedButton() !\u003d\u003d ui.Button.OK) {\n    return;\n  }\n  \n  const path \u003d pathResponse.getResponseText().trim();\n  if (!path) {\n    ui.alert(\"MCP Proxy\", \"Path cannot be empty.\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  // Prompt for query params (optional)\n  const paramsResponse \u003d ui.prompt(\n    \"MCP Proxy ‚Äî HTTP GET Tool\",\n    \"Enter query params (optional, format: key\u003dvalue\u0026key2\u003dvalue2):\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  let queryParams \u003d {};\n  if (paramsResponse.getSelectedButton() \u003d\u003d\u003d ui.Button.OK) {\n    const paramsText \u003d paramsResponse.getResponseText().trim();\n    if (paramsText) {\n      const pairs \u003d paramsText.split(\"\u0026\");\n      for (let i \u003d 0; i \u003c pairs.length; i++) {\n        const pair \u003d pairs[i].split(\"\u003d\");\n        if (pair.length \u003d\u003d\u003d 2) {\n          queryParams[pair[0].trim()] \u003d pair[1].trim();\n        }\n      }\n    }\n  }\n  \n  try {\n    // Build URL manually using MCP_HTTP private functions pattern\n    const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n    const sh \u003d ss.getSheetByName(\"SETTINGS\");\n    if (!sh) throw new Error(\"SETTINGS sheet not found\");\n    \n    let baseUrl \u003d \"\";\n    let apiKey \u003d \"\";\n    const values \u003d sh.getDataRange().getValues();\n    for (let i \u003d 1; i \u003c values.length; i++) {\n      const key \u003d String(values[i][0] || \"\").trim();\n      if (key \u003d\u003d\u003d \"mcp_proxy_url\") {\n        baseUrl \u003d String(values[i][1] || \"\").trim();\n      } else if (key \u003d\u003d\u003d \"mcp_api_key\") {\n        apiKey \u003d String(values[i][1] || \"\").trim();\n      }\n    }\n    \n    if (!baseUrl) throw new Error(\"SETTINGS: mcp_proxy_url not found\");\n    if (!apiKey) throw new Error(\"SETTINGS: mcp_api_key not found\");\n    \n    let url \u003d baseUrl + path;\n    if (Object.keys(queryParams).length \u003e 0) {\n      const params \u003d [];\n      for (const key in queryParams) {\n        if (queryParams.hasOwnProperty(key)) {\n          params.push(encodeURIComponent(key) + \"\u003d\" + encodeURIComponent(queryParams[key]));\n        }\n      }\n      if (params.length \u003e 0) {\n        url +\u003d \"?\" + params.join(\"\u0026\");\n      }\n    }\n    \n    const result \u003d UrlFetchApp.fetch(url, {\n      method: \"get\",\n      headers: {\n        \"X-API-Key\": apiKey,\n        \"Accept\": \"application/json\"\n      },\n      muteHttpExceptions: true\n    });\n    \n    const statusCode \u003d result.getResponseCode();\n    const contentText \u003d result.getContentText();\n    \n    ui.alert(\n      \"MCP Proxy ‚Äî HTTP GET Result\",\n      \"Status: \" + statusCode + \"\\n\\n\" +\n      \"Response:\\n\" + contentText.slice(0, 1500),\n      ui.ButtonSet.OK\n    );\n    \n  } catch (e) {\n    ui.alert(\n      \"MCP Proxy ‚Äî Error\",\n      \"Exception: \" + String(e.message || e),\n      ui.ButtonSet.OK\n    );\n  }\n}\n"},{"id":"fd26495a-8f4f-4fe6-a28d-a08f7581ce92","name":"G15_AUDIT_READ_EVERYWHERE","type":"server_js","source":"/**\n * FILE: G15_AUDIT_READ_EVERYWHERE.gs\n * PROJECT: IAPF MEMORY HUB V1\n * VERSION: v1.0.0\n * \n * Objectif: \"√âlia doit pouvoir voir vraiment tout\"\n * - Lecture partout (READ-ONLY) sans √©criture\n * - R√©sultat OK/KO par brique + premier point bloquant\n * - Code + erreur + correlation_id\n * \n * Briques test√©es:\n * 1. Cloud Run (proxy MCP) - /health, /docs-json, /infra/whoami, /sheets?limit\n * 2. Hub Sheets - SETTINGS, MEMORY_LOG, DRIVE_INVENTORY\n * 3. Drive - acc√®s r√©el aux dossiers (snapshots, archives, root m√©moire)\n * 4. GitHub - lecture repo/commits\n * 5. Apps Script - introspection (projet/version/deployments)\n * 6. Logs Cloud Run - lecture logs mcp-memory-proxy\n * \n * D√©pendances:\n * - G14_MCP_HTTP_CLIENT.gs (module MCP_HTTP)\n * - SETTINGS: mcp_proxy_url, mcp_api_key, github_token, etc.\n */\n\nvar MCP_AUDIT \u003d (function() {\n\n  /**\n   * Get setting value from SETTINGS sheet\n   */\n  function _getSetting_(key) {\n    try {\n      const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n      const sh \u003d ss.getSheetByName(\"SETTINGS\");\n      if (!sh) return \"\";\n      \n      const values \u003d sh.getDataRange().getValues();\n      for (let i \u003d 1; i \u003c values.length; i++) {\n        const k \u003d String(values[i][0] || \"\").trim();\n        if (k \u003d\u003d\u003d key) {\n          return String(values[i][1] || \"\").trim();\n        }\n      }\n      return \"\";\n    } catch (e) {\n      return \"\";\n    }\n  }\n\n  /**\n   * Audit Cloud Run Proxy (MCP Memory Proxy)\n   */\n  function _auditCloudRunProxy_() {\n    const results \u003d [];\n    \n    try {\n      // Test 1: GET /health\n      const health \u003d MCP_HTTP.getHealth();\n      results.push({\n        test: \"Proxy /health\",\n        ok: health.ok,\n        status: health.status,\n        body_excerpt: health.ok ? \"version\u003d\" + (health.body.version || \"N/A\") : String(health.error),\n        correlation_id: health.correlation_id || \"N/A\",\n        error: health.error\n      });\n      \n      // Test 2: GET /infra/whoami\n      const whoami \u003d MCP_HTTP.getInfraWhoami();\n      results.push({\n        test: \"Proxy /infra/whoami\",\n        ok: whoami.ok,\n        status: whoami.status,\n        body_excerpt: whoami.ok ? \"revision\u003d\" + ((whoami.body \u0026\u0026 whoami.body.cloud_run_revision) || \"N/A\") : String(whoami.error),\n        correlation_id: whoami.correlation_id || \"N/A\",\n        error: whoami.error\n      });\n      \n      // Test 3: GET /docs-json\n      const docs \u003d MCP_HTTP.getDocsJson();\n      results.push({\n        test: \"Proxy /docs-json\",\n        ok: docs.ok,\n        status: docs.status,\n        body_excerpt: docs.ok ? \"endpoints\u003d\" + ((docs.body \u0026\u0026 docs.body.endpoints \u0026\u0026 docs.body.endpoints.length) || 0) : String(docs.error),\n        correlation_id: docs.correlation_id || \"N/A\",\n        error: docs.error\n      });\n      \n      // Test 4: GET /sheets/SETTINGS?limit\u003d1\n      const settings \u003d MCP_HTTP.getSheet(\"SETTINGS\", {limit: 1});\n      results.push({\n        test: \"Proxy /sheets/SETTINGS?limit\u003d1\",\n        ok: settings.ok,\n        status: settings.status,\n        body_excerpt: settings.ok ? \"row_count\u003d\" + ((settings.body \u0026\u0026 settings.body.row_count) || 0) : String(settings.error),\n        correlation_id: settings.correlation_id || \"N/A\",\n        error: settings.error\n      });\n      \n    } catch (e) {\n      results.push({\n        test: \"Proxy (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Audit Hub Sheets (direct read)\n   */\n  function _auditHubSheets_() {\n    const results \u003d [];\n    \n    try {\n      const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n      const sheetsToTest \u003d [\"SETTINGS\", \"MEMORY_LOG\", \"DRIVE_INVENTORY\"];\n      \n      for (let i \u003d 0; i \u003c sheetsToTest.length; i++) {\n        const sheetName \u003d sheetsToTest[i];\n        const sh \u003d ss.getSheetByName(sheetName);\n        \n        if (sh) {\n          const rowCount \u003d sh.getLastRow();\n          results.push({\n            test: \"Hub Sheets \" + sheetName,\n            ok: true,\n            status: 200,\n            body_excerpt: \"rows\u003d\" + rowCount,\n            correlation_id: \"N/A\",\n            error: null\n          });\n        } else {\n          results.push({\n            test: \"Hub Sheets \" + sheetName,\n            ok: false,\n            status: 404,\n            body_excerpt: \"N/A\",\n            correlation_id: \"N/A\",\n            error: \"Sheet not found\"\n          });\n        }\n      }\n      \n    } catch (e) {\n      results.push({\n        test: \"Hub Sheets (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Audit Drive (acc√®s r√©el aux dossiers)\n   */\n  function _auditDrive_() {\n    const results \u003d [];\n    \n    try {\n      const folderKeys \u003d [\n        {key: \"snapshots_folder_id\", label: \"Snapshots\"},\n        {key: \"archives_folder_id\", label: \"Archives\"},\n        {key: \"memory_root_folder_id\", label: \"Memory Root\"}\n      ];\n      \n      for (let i \u003d 0; i \u003c folderKeys.length; i++) {\n        const item \u003d folderKeys[i];\n        const folderId \u003d _getSetting_(item.key);\n        \n        if (!folderId) {\n          results.push({\n            test: \"Drive \" + item.label,\n            ok: false,\n            status: 404,\n            body_excerpt: \"N/A\",\n            correlation_id: \"N/A\",\n            error: \"SETTINGS: \" + item.key + \" not found\"\n          });\n          continue;\n        }\n        \n        try {\n          const folder \u003d DriveApp.getFolderById(folderId);\n          const files \u003d folder.getFiles();\n          let fileCount \u003d 0;\n          while (files.hasNext() \u0026\u0026 fileCount \u003c 10) {\n            files.next();\n            fileCount++;\n          }\n          \n          results.push({\n            test: \"Drive \" + item.label,\n            ok: true,\n            status: 200,\n            body_excerpt: \"id\u003d\" + folderId + \", files(sample)\u003d\" + fileCount,\n            correlation_id: \"N/A\",\n            error: null\n          });\n        } catch (e) {\n          results.push({\n            test: \"Drive \" + item.label,\n            ok: false,\n            status: 403,\n            body_excerpt: \"N/A\",\n            correlation_id: \"N/A\",\n            error: \"Access denied: \" + String(e.message || e)\n          });\n        }\n      }\n      \n    } catch (e) {\n      results.push({\n        test: \"Drive (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Audit GitHub (lecture repo/commits)\n   */\n  function _auditGitHub_() {\n    const results \u003d [];\n    \n    try {\n      const githubToken \u003d _getSetting_(\"github_token\");\n      const githubRepo \u003d _getSetting_(\"github_repo\"); // format: \"owner/repo\"\n      \n      if (!githubToken) {\n        results.push({\n          test: \"GitHub Auth\",\n          ok: false,\n          status: 401,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"SETTINGS: github_token not found\"\n        });\n        return results;\n      }\n      \n      if (!githubRepo) {\n        results.push({\n          test: \"GitHub Repo\",\n          ok: false,\n          status: 404,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"SETTINGS: github_repo not found (format: owner/repo)\"\n        });\n        return results;\n      }\n      \n      // Test 1: GET /repos/{owner}/{repo}\n      const repoUrl \u003d \"https://api.github.com/repos/\" + githubRepo;\n      const repoResp \u003d UrlFetchApp.fetch(repoUrl, {\n        method: \"get\",\n        headers: {\n          \"Authorization\": \"token \" + githubToken,\n          \"Accept\": \"application/vnd.github.v3+json\"\n        },\n        muteHttpExceptions: true\n      });\n      \n      const repoStatus \u003d repoResp.getResponseCode();\n      if (repoStatus \u003d\u003d\u003d 200) {\n        const repoData \u003d JSON.parse(repoResp.getContentText());\n        results.push({\n          test: \"GitHub Repo Info\",\n          ok: true,\n          status: 200,\n          body_excerpt: \"default_branch\u003d\" + (repoData.default_branch || \"N/A\"),\n          correlation_id: \"N/A\",\n          error: null\n        });\n        \n        // Test 2: GET /repos/{owner}/{repo}/commits?per_page\u003d5\n        const commitsUrl \u003d \"https://api.github.com/repos/\" + githubRepo + \"/commits?per_page\u003d5\";\n        const commitsResp \u003d UrlFetchApp.fetch(commitsUrl, {\n          method: \"get\",\n          headers: {\n            \"Authorization\": \"token \" + githubToken,\n            \"Accept\": \"application/vnd.github.v3+json\"\n          },\n          muteHttpExceptions: true\n        });\n        \n        const commitsStatus \u003d commitsResp.getResponseCode();\n        if (commitsStatus \u003d\u003d\u003d 200) {\n          const commitsData \u003d JSON.parse(commitsResp.getContentText());\n          const lastSha \u003d (commitsData.length \u003e 0 \u0026\u0026 commitsData[0].sha) ? commitsData[0].sha.slice(0, 7) : \"N/A\";\n          results.push({\n            test: \"GitHub Commits (last 5)\",\n            ok: true,\n            status: 200,\n            body_excerpt: \"count\u003d\" + commitsData.length + \", last_sha\u003d\" + lastSha,\n            correlation_id: \"N/A\",\n            error: null\n          });\n        } else {\n          results.push({\n            test: \"GitHub Commits\",\n            ok: false,\n            status: commitsStatus,\n            body_excerpt: \"N/A\",\n            correlation_id: \"N/A\",\n            error: \"HTTP \" + commitsStatus\n          });\n        }\n        \n      } else {\n        results.push({\n          test: \"GitHub Repo Info\",\n          ok: false,\n          status: repoStatus,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"HTTP \" + repoStatus\n        });\n      }\n      \n    } catch (e) {\n      results.push({\n        test: \"GitHub (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Audit Apps Script (introspection projet/version/deployments)\n   */\n  function _auditAppsScript_() {\n    const results \u003d [];\n    \n    try {\n      const scriptId \u003d ScriptApp.getScriptId();\n      const token \u003d ScriptApp.getOAuthToken();\n      \n      // Test 1: GET /v1/projects/{scriptId}\n      const projectUrl \u003d \"https://script.googleapis.com/v1/projects/\" + scriptId;\n      const projectResp \u003d UrlFetchApp.fetch(projectUrl, {\n        method: \"get\",\n        headers: {\n          \"Authorization\": \"Bearer \" + token\n        },\n        muteHttpExceptions: true\n      });\n      \n      const projectStatus \u003d projectResp.getResponseCode();\n      if (projectStatus \u003d\u003d\u003d 200) {\n        const projectData \u003d JSON.parse(projectResp.getContentText());\n        results.push({\n          test: \"Apps Script Project\",\n          ok: true,\n          status: 200,\n          body_excerpt: \"title\u003d\" + (projectData.title || \"N/A\"),\n          correlation_id: \"N/A\",\n          error: null\n        });\n      } else {\n        results.push({\n          test: \"Apps Script Project\",\n          ok: false,\n          status: projectStatus,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"HTTP \" + projectStatus + \" (OAuth scope may be missing)\"\n        });\n      }\n      \n      // Test 2: GET /v1/projects/{scriptId}/deployments\n      const deploymentsUrl \u003d \"https://script.googleapis.com/v1/projects/\" + scriptId + \"/deployments\";\n      const deploymentsResp \u003d UrlFetchApp.fetch(deploymentsUrl, {\n        method: \"get\",\n        headers: {\n          \"Authorization\": \"Bearer \" + token\n        },\n        muteHttpExceptions: true\n      });\n      \n      const deploymentsStatus \u003d deploymentsResp.getResponseCode();\n      if (deploymentsStatus \u003d\u003d\u003d 200) {\n        const deploymentsData \u003d JSON.parse(deploymentsResp.getContentText());\n        const deploymentCount \u003d (deploymentsData.deployments \u0026\u0026 deploymentsData.deployments.length) || 0;\n        results.push({\n          test: \"Apps Script Deployments\",\n          ok: true,\n          status: 200,\n          body_excerpt: \"count\u003d\" + deploymentCount,\n          correlation_id: \"N/A\",\n          error: null\n        });\n      } else {\n        results.push({\n          test: \"Apps Script Deployments\",\n          ok: false,\n          status: deploymentsStatus,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"HTTP \" + deploymentsStatus + \" (OAuth scope may be missing)\"\n        });\n      }\n      \n    } catch (e) {\n      results.push({\n        test: \"Apps Script (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Audit Logs Cloud Run (lecture logs mcp-memory-proxy)\n   */\n  function _auditCloudRunLogs_() {\n    const results \u003d [];\n    \n    try {\n      const proxyUrl \u003d _getSetting_(\"mcp_proxy_url\");\n      const apiKey \u003d _getSetting_(\"mcp_api_key\");\n      \n      if (!proxyUrl || !apiKey) {\n        results.push({\n          test: \"Cloud Run Logs\",\n          ok: false,\n          status: 401,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"SETTINGS: mcp_proxy_url or mcp_api_key not found\"\n        });\n        return results;\n      }\n      \n      // Test: POST /infra/logs/query\n      const logsUrl \u003d proxyUrl + \"/infra/logs/query\";\n      const logsPayload \u003d {\n        resource_type: \"cloud_run_revision\",\n        name: \"mcp-memory-proxy\",\n        time_range_minutes: 60,\n        limit: 10\n      };\n      \n      const logsResp \u003d UrlFetchApp.fetch(logsUrl, {\n        method: \"post\",\n        contentType: \"application/json\",\n        payload: JSON.stringify(logsPayload),\n        headers: {\n          \"X-API-Key\": apiKey\n        },\n        muteHttpExceptions: true\n      });\n      \n      const logsStatus \u003d logsResp.getResponseCode();\n      if (logsStatus \u003d\u003d\u003d 200) {\n        const logsData \u003d JSON.parse(logsResp.getContentText());\n        const entryCount \u003d (logsData.entries \u0026\u0026 logsData.entries.length) || 0;\n        results.push({\n          test: \"Cloud Run Logs Query\",\n          ok: true,\n          status: 200,\n          body_excerpt: \"entries\u003d\" + entryCount,\n          correlation_id: logsData.correlation_id || \"N/A\",\n          error: null\n        });\n      } else if (logsStatus \u003d\u003d\u003d 403) {\n        results.push({\n          test: \"Cloud Run Logs Query\",\n          ok: false,\n          status: 403,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"POST blocked (READ_ONLY_MODE\u003dtrue)\"\n        });\n      } else {\n        results.push({\n          test: \"Cloud Run Logs Query\",\n          ok: false,\n          status: logsStatus,\n          body_excerpt: \"N/A\",\n          correlation_id: \"N/A\",\n          error: \"HTTP \" + logsStatus\n        });\n      }\n      \n    } catch (e) {\n      results.push({\n        test: \"Cloud Run Logs (exception)\",\n        ok: false,\n        status: 0,\n        body_excerpt: \"N/A\",\n        correlation_id: \"N/A\",\n        error: \"Exception: \" + String(e.message || e)\n      });\n    }\n    \n    return results;\n  }\n\n  /**\n   * Public API: Run full audit (all briques)\n   * Returns array of all results\n   */\n  function runFullAudit() {\n    const allResults \u003d [];\n    \n    // Brique 1: Cloud Run Proxy\n    const proxyResults \u003d _auditCloudRunProxy_();\n    allResults.push({\n      brique: \"1. Cloud Run Proxy (MCP)\",\n      tests: proxyResults\n    });\n    \n    // Brique 2: Hub Sheets\n    const sheetsResults \u003d _auditHubSheets_();\n    allResults.push({\n      brique: \"2. Hub Sheets (direct)\",\n      tests: sheetsResults\n    });\n    \n    // Brique 3: Drive\n    const driveResults \u003d _auditDrive_();\n    allResults.push({\n      brique: \"3. Drive (folders)\",\n      tests: driveResults\n    });\n    \n    // Brique 4: GitHub\n    const githubResults \u003d _auditGitHub_();\n    allResults.push({\n      brique: \"4. GitHub (repo/commits)\",\n      tests: githubResults\n    });\n    \n    // Brique 5: Apps Script\n    const appsScriptResults \u003d _auditAppsScript_();\n    allResults.push({\n      brique: \"5. Apps Script (project)\",\n      tests: appsScriptResults\n    });\n    \n    // Brique 6: Cloud Run Logs\n    const logsResults \u003d _auditCloudRunLogs_();\n    allResults.push({\n      brique: \"6. Cloud Run Logs\",\n      tests: logsResults\n    });\n    \n    return allResults;\n  }\n\n  return {\n    runFullAudit: runFullAudit\n  };\n\n})();\n\n/**\n * Menu action: Audit Lecture Partout\n * Called from G01_UI_MENU.gs\n */\nfunction MCP_AUDIT_readEverywhere() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const response \u003d ui.alert(\n    \"MCP ‚Äî Audit Lecture Partout\",\n    \"This audit will test READ access to all briques:\\n\\n\" +\n    \"1. Cloud Run Proxy (/health, /infra/whoami, /sheets)\\n\" +\n    \"2. Hub Sheets (SETTINGS, MEMORY_LOG, DRIVE_INVENTORY)\\n\" +\n    \"3. Drive (snapshots, archives, memory root)\\n\" +\n    \"4. GitHub (repo info, last 5 commits)\\n\" +\n    \"5. Apps Script (project, deployments)\\n\" +\n    \"6. Cloud Run Logs (query mcp-memory-proxy)\\n\\n\" +\n    \"Continue?\",\n    ui.ButtonSet.YES_NO\n  );\n  \n  if (response !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP Audit\", \"Audit cancelled.\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const results \u003d MCP_AUDIT.runFullAudit();\n    \n    // Format results for display\n    const lines \u003d [];\n    lines.push(\"\u003d\u003d\u003d AUDIT LECTURE PARTOUT \u003d\u003d\u003d\");\n    lines.push(\"\");\n    \n    let totalTests \u003d 0;\n    let passedTests \u003d 0;\n    \n    for (let i \u003d 0; i \u003c results.length; i++) {\n      const brique \u003d results[i];\n      lines.push(brique.brique);\n      lines.push(\"\");\n      \n      for (let j \u003d 0; j \u003c brique.tests.length; j++) {\n        const test \u003d brique.tests[j];\n        totalTests++;\n        if (test.ok) passedTests++;\n        \n        const icon \u003d test.ok ? \"‚úÖ\" : \"‚ùå\";\n        lines.push(icon + \" \" + test.test);\n        lines.push(\"   Status: \" + test.status);\n        lines.push(\"   Body: \" + test.body_excerpt);\n        if (!test.ok \u0026\u0026 test.error) {\n          lines.push(\"   ‚ö†Ô∏è Error: \" + test.error);\n        }\n        if (test.correlation_id \u0026\u0026 test.correlation_id !\u003d\u003d \"N/A\") {\n          lines.push(\"   Correlation: \" + test.correlation_id);\n        }\n        lines.push(\"\");\n      }\n    }\n    \n    lines.push(\"\u003d\u003d\u003d SUMMARY \u003d\u003d\u003d\");\n    lines.push(\"Total tests: \" + totalTests);\n    lines.push(\"Passed: \" + passedTests);\n    lines.push(\"Failed: \" + (totalTests - passedTests));\n    lines.push(\"\");\n    lines.push(\"Timestamp: \" + new Date().toISOString());\n    \n    // Show results in alert (truncated if too long)\n    const message \u003d lines.join(\"\\n\");\n    const maxLen \u003d 2000;\n    const displayMessage \u003d message.length \u003e maxLen ? message.slice(0, maxLen) + \"\\n\\n... (truncated)\" : message;\n    \n    ui.alert(\n      \"MCP ‚Äî Audit Results\",\n      displayMessage,\n      ui.ButtonSet.OK\n    );\n    \n    // Also log to Logger for full details\n    Logger.log(\"\u003d\u003d\u003d FULL AUDIT RESULTS \u003d\u003d\u003d\");\n    Logger.log(JSON.stringify(results, null, 2));\n    \n  } catch (e) {\n    ui.alert(\n      \"MCP Audit ‚Äî Error\",\n      \"Exception: \" + String(e.message || e) + \"\\n\\n\" +\n      \"Check Logger (Ctrl+Enter) for details.\",\n      ui.ButtonSet.OK\n    );\n    Logger.log(\"Audit exception: \" + String(e.stack || e));\n  }\n}\n"},{"id":"e22537d3-6ae4-4d30-aeab-0344d8861bbf","name":"G16_MCP_ACTIONS_EXTENDED","type":"server_js","source":"// File: /CODE/G16_MCP_ACTIONS_EXTENDED.gs\n// HUB IAPF Memory ‚Äî Phase 2 Actions MCP (Extension contr√¥l√©e)\n\n/**\n * PHASE 2 MCP ACTIONS - One-Shot Complete\n * \n * Menu \"Actions MCP\" unifi√© avec 18 endpoints (6 domaines):\n * - Drive (4 endpoints READ_ONLY)\n * - Apps Script (4 endpoints READ_ONLY)\n * - Cloud Run (3 endpoints READ_ONLY)\n * - Secrets (4 endpoints: 2 READ + 2 WRITE gouvern√©)\n * - Web (2 endpoints READ_ONLY)\n * - Terminal (1 endpoint WRITE gouvern√©)\n * \n * Principes:\n * - READ_ONLY par d√©faut\n * - Journalisation obligatoire (MEMORY_LOG + run_id)\n * - Pagination + limites\n * - Redaction syst√©matique\n * - Mode DRY_RUN disponible (WRITE)\n * - Un seul GO pour WRITE_APPLY\n */\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// DRIVE ACTIONS\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_driveListTree() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const folderIdResp \u003d ui.prompt(\n    \"MCP Drive ‚Äî List Tree\",\n    \"Entrer l\u0027ID du folder Drive:\\n(ex: 1ABC...)\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (folderIdResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const folderId \u003d folderIdResp.getResponseText().trim();\n  if (!folderId) {\n    ui.alert(\"Error\", \"Folder ID requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.driveListTree(folderId, {\n      max_depth: 2,\n      limit: 100\n    });\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Drive ‚Äî List Tree OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Folder: ${response.folder_name}\\n` +\n        `Items: ${response.total_items}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_driveFileMetadata() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const fileIdResp \u003d ui.prompt(\n    \"MCP Drive ‚Äî File Metadata\",\n    \"Entrer l\u0027ID du fichier Drive:\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (fileIdResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const fileId \u003d fileIdResp.getResponseText().trim();\n  if (!fileId) {\n    ui.alert(\"Error\", \"File ID requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.driveFileMetadata(fileId);\n    \n    if (response.ok) {\n      const file \u003d response.file;\n      ui.alert(\n        \"MCP Drive ‚Äî Metadata OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Nom: ${file.name}\\n` +\n        `Type: ${file.mimeType}\\n` +\n        `Taille: ${file.size} bytes\\n` +\n        `Modifi√©: ${file.modifiedTime}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_driveSearch() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const queryResp \u003d ui.prompt(\n    \"MCP Drive ‚Äî Search\",\n    \"Entrer la requ√™te de recherche:\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (queryResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const query \u003d queryResp.getResponseText().trim();\n  if (!query) {\n    ui.alert(\"Error\", \"Query requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.driveSearch(query, {limit: 10});\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Drive ‚Äî Search OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Query: ${response.query}\\n` +\n        `R√©sultats: ${response.total_results}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// APPS SCRIPT ACTIONS\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_appsScriptDeployments() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const scriptId \u003d ScriptApp.getScriptId();\n  \n  try {\n    const response \u003d MCP_HTTP.appsScriptDeployments(scriptId, {limit: 10});\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Apps Script ‚Äî Deployments OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Script ID: ${scriptId}\\n` +\n        `Deployments: ${response.total_deployments}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_appsScriptStructure() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const scriptId \u003d ScriptApp.getScriptId();\n  \n  try {\n    const response \u003d MCP_HTTP.appsScriptStructure(scriptId);\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Apps Script ‚Äî Structure OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Projet: ${response.project_name}\\n` +\n        `Fichiers: ${response.total_files}\\n` +\n        `Fonctions: ${response.total_functions}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// CLOUD RUN ACTIONS\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_cloudRunServiceStatus() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const serviceNameResp \u003d ui.prompt(\n    \"MCP Cloud Run ‚Äî Service Status\",\n    \"Entrer le nom du service:\\n(ex: mcp-memory-proxy)\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (serviceNameResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const serviceName \u003d serviceNameResp.getResponseText().trim();\n  if (!serviceName) {\n    ui.alert(\"Error\", \"Service name requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.cloudRunServiceStatus(serviceName);\n    \n    if (response.ok) {\n      const status \u003d response.status;\n      ui.alert(\n        \"MCP Cloud Run ‚Äî Service Status OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Service: ${serviceName}\\n` +\n        `Revision: ${status.latest_ready_revision}\\n` +\n        `Ready: ${status.ready_condition}\\n` +\n        `Env: ${status.environment}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// SECRET MANAGER ACTIONS (GOVERNED)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_secretsList() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  try {\n    const response \u003d MCP_HTTP.secretsList({limit: 20});\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Secret Manager ‚Äî List OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Projet: ${response.project_id}\\n` +\n        `Secrets: ${response.total_secrets}\\n\\n` +\n        `‚ö†Ô∏è Valeurs JAMAIS retourn√©es (seulement m√©tadonn√©es)\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_secretGetReference() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const secretIdResp \u003d ui.prompt(\n    \"MCP Secret Manager ‚Äî Get Reference\",\n    \"Entrer l\u0027ID du secret:\\n(ex: mcp_api_key)\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (secretIdResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const secretId \u003d secretIdResp.getResponseText().trim();\n  if (!secretId) {\n    ui.alert(\"Error\", \"Secret ID requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.secretGetReference(secretId);\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Secret Manager ‚Äî Reference OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Secret ID: ${secretId}\\n` +\n        `Version: ${response.version}\\n` +\n        `Reference: ${response.reference}\\n\\n` +\n        `‚ö†Ô∏è Valeur: [REDACTED] (jamais retourn√©e)\\n\\n` +\n        `Stocker cette r√©f√©rence dans SETTINGS`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_secretCreateDryRun() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const secretIdResp \u003d ui.prompt(\n    \"MCP Secret Manager ‚Äî Create (DRY_RUN)\",\n    \"Entrer l\u0027ID du nouveau secret:\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (secretIdResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const secretId \u003d secretIdResp.getResponseText().trim();\n  if (!secretId) {\n    ui.alert(\"Error\", \"Secret ID requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.secretCreate(secretId, \"dummy_value_for_dryrun\", {\n      dry_run: true,\n      labels: {env: \"staging\", service: \"test\"}\n    });\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Secret Manager ‚Äî Create DRY_RUN OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Mode: ${response.dry_run ? \"DRY_RUN\" : \"APPLIED\"}\\n` +\n        `Secret ID: ${secretId}\\n` +\n        `Reference: ${response.reference}\\n\\n` +\n        `‚ö†Ô∏è ${response.message}\\n\\n` +\n        `Pour appliquer: utiliser MCP_ACTION_secretCreateApply()`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\nfunction MCP_ACTION_secretCreateApply() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const secretIdResp \u003d ui.prompt(\n    \"MCP Secret Manager ‚Äî Create (APPLY)\",\n    \"Entrer l\u0027ID du nouveau secret:\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (secretIdResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const secretId \u003d secretIdResp.getResponseText().trim();\n  if (!secretId) {\n    ui.alert(\"Error\", \"Secret ID requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  const valueResp \u003d ui.prompt(\n    \"MCP Secret Manager ‚Äî Create (APPLY)\",\n    \"Entrer la valeur du secret:\\n(sera redact√©e dans tous les logs)\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (valueResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const value \u003d valueResp.getResponseText().trim();\n  if (!value) {\n    ui.alert(\"Error\", \"Valeur requise\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  // GO Confirmation\n  const confirm \u003d ui.alert(\n    \"MCP Secret Manager ‚Äî Create (APPLY)\",\n    `‚ö†Ô∏è WRITE_APPLY\\n\\n` +\n    `Domaine: Secret Manager\\n` +\n    `Action: Create secret \"${secretId}\"\\n` +\n    `Env: STAGING\\n\\n` +\n    `Cette action cr√©era le secret r√©ellement.\\n\\n` +\n    `Continuer avec WRITE_APPLY?`,\n    ui.ButtonSet.YES_NO\n  );\n  \n  if (confirm !\u003d\u003d ui.Button.YES) {\n    ui.alert(\"MCP\", \"Action annul√©e\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.secretCreate(secretId, value, {\n      dry_run: false,\n      labels: {env: \"staging\"}\n    });\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Secret Manager ‚Äî Create APPLIED ‚úÖ\",\n        `run_id: ${response.run_id}\\n` +\n        `Mode: APPLIED\\n` +\n        `Secret ID: ${secretId}\\n` +\n        `Reference: ${response.reference}\\n\\n` +\n        `‚úÖ ${response.message}\\n\\n` +\n        `Stocker cette r√©f√©rence dans SETTINGS:\\n` +\n        `${response.reference}`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// WEB ACCESS ACTIONS\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_webSearch() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const queryResp \u003d ui.prompt(\n    \"MCP Web ‚Äî Search\",\n    \"Entrer la requ√™te de recherche web:\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (queryResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const query \u003d queryResp.getResponseText().trim();\n  if (!query) {\n    ui.alert(\"Error\", \"Query requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.webSearch(query, {max_results: 5});\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Web ‚Äî Search OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Query: ${response.query}\\n` +\n        `R√©sultats: ${response.total_results}\\n` +\n        `Quota restant: ${response.quota_remaining}\\n\\n` +\n        `Voir MEMORY_LOG pour d√©tails`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n// TERMINAL RUNNER ACTION (GOVERNED)\n// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nfunction MCP_ACTION_terminalRunReadOnly() {\n  const ui \u003d SpreadsheetApp.getUi();\n  \n  const commandResp \u003d ui.prompt(\n    \"MCP Terminal ‚Äî Run (READ_ONLY)\",\n    \"Entrer la commande (allowlist READ_ONLY):\\nEx: gcloud run services describe mcp-memory-proxy --region\u003dus-central1\",\n    ui.ButtonSet.OK_CANCEL\n  );\n  \n  if (commandResp.getSelectedButton() !\u003d\u003d ui.Button.OK) return;\n  \n  const command \u003d commandResp.getResponseText().trim();\n  if (!command) {\n    ui.alert(\"Error\", \"Command requis\", ui.ButtonSet.OK);\n    return;\n  }\n  \n  try {\n    const response \u003d MCP_HTTP.terminalRun(command, {\n      mode: \"READ_ONLY\",\n      dry_run: false\n    });\n    \n    if (response.ok) {\n      ui.alert(\n        \"MCP Terminal ‚Äî Run OK\",\n        `run_id: ${response.run_id}\\n` +\n        `Command: ${command}\\n` +\n        `Exit code: ${response.exit_code}\\n` +\n        `Duration: ${response.duration_ms}ms\\n\\n` +\n        `Voir MEMORY_LOG pour output complet`,\n        ui.ButtonSet.OK\n      );\n    } else {\n      ui.alert(\"Error\", response.error || \"Unknown error\", ui.ButtonSet.OK);\n    }\n  } catch (e) {\n    ui.alert(\"Error\", String(e), ui.ButtonSet.OK);\n  }\n}\n"},{"id":"b02d8bcb-9af9-46c1-9580-297eba8a02bd","name":"G17_MCP_HTTP_CLIENT_EXTENDED","type":"server_js","source":"// File: /CODE/G17_MCP_HTTP_CLIENT_EXTENDED.gs\n// HUB IAPF Memory ‚Äî Phase 2 HTTP Client Extended (Drive, Apps Script, Cloud Run, Secrets, Web, Terminal)\n\n/**\n * Client HTTP pour les endpoints Phase 2 MCP\n * Wrapper d\u0027acc√®s au proxy mcp-memory-proxy avec:\n * - run_id (c√¥t√© proxy) + journalisation obligatoire\n * - Retry (5xx) + erreurs explicites\n * - Pagination support (page_token)\n *\n * IMPORTANT (Apps Script):\n * - URLSearchParams n\u0027existe PAS \u003d\u003e querystring construit manuellement\n * - UrlFetchApp n\u0027expose pas de \"timeout\" param -\u003e on √©vite les options non support√©es\n */\n\nvar MCP_HTTP \u003d (function () {\n\n  // Fallback si SETTINGS manquant (dev uniquement)\n  const FALLBACK_BASE_URL \u003d \"https://mcp-memory-proxy-522732657254.us-central1.run.app\";\n  const MAX_RETRIES \u003d 3;\n\n  // ----------------------------------------------------------------------------\n  // SETTINGS helpers\n  // ----------------------------------------------------------------------------\n\n  function _getSettingsValue_(key) {\n    try {\n      const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n      const settingsSheet \u003d ss.getSheetByName(\"SETTINGS\");\n      if (!settingsSheet) return null;\n\n      const data \u003d settingsSheet.getDataRange().getValues();\n      for (let i \u003d 1; i \u003c data.length; i++) {\n        if (data[i][0] \u003d\u003d\u003d key) return data[i][1];\n      }\n      return null;\n    } catch (e) {\n      Logger.log(\"[MCP_HTTP] Error reading SETTINGS: \" + e);\n      return null;\n    }\n  }\n\n  function _getApiKey_() {\n    const apiKey \u003d _getSettingsValue_(\"mcp_api_key\");\n    return apiKey ? String(apiKey).trim() : null;\n  }\n\n  function _getProxyUrl_() {\n    const fromSettings \u003d _getSettingsValue_(\"mcp_proxy_url\");\n    if (fromSettings \u0026\u0026 String(fromSettings).trim()) return String(fromSettings).trim();\n    return FALLBACK_BASE_URL;\n  }\n\n  // ----------------------------------------------------------------------------\n  // Querystring helper (Apps Script compatible)\n  // ----------------------------------------------------------------------------\n\n  function _toQueryString_(params) {\n    if (!params) return \"\";\n    const parts \u003d [];\n\n    const keys \u003d Object.keys(params);\n    for (let i \u003d 0; i \u003c keys.length; i++) {\n      const k \u003d keys[i];\n      const v \u003d params[k];\n\n      // Skip null/undefined/empty\n      if (v \u003d\u003d\u003d null || v \u003d\u003d\u003d undefined) continue;\n      if (typeof v \u003d\u003d\u003d \"string\" \u0026\u0026 v.trim() \u003d\u003d\u003d \"\") continue;\n\n      // Array \u003d\u003e repeat key\n      if (Array.isArray(v)) {\n        for (let j \u003d 0; j \u003c v.length; j++) {\n          const av \u003d v[j];\n          if (av \u003d\u003d\u003d null || av \u003d\u003d\u003d undefined) continue;\n          parts.push(encodeURIComponent(k) + \"\u003d\" + encodeURIComponent(String(av)));\n        }\n        continue;\n      }\n\n      // Bool \u003d\u003e \"true/false\"\n      if (typeof v \u003d\u003d\u003d \"boolean\") {\n        parts.push(encodeURIComponent(k) + \"\u003d\" + encodeURIComponent(v ? \"true\" : \"false\"));\n        continue;\n      }\n\n      // Default\n      parts.push(encodeURIComponent(k) + \"\u003d\" + encodeURIComponent(String(v)));\n    }\n\n    return parts.length ? (\"?\" + parts.join(\"\u0026\")) : \"\";\n  }\n\n  // ----------------------------------------------------------------------------\n  // HTTP core\n  // ----------------------------------------------------------------------------\n\n  function _makeRequest_(method, endpoint, options) {\n    options \u003d options || {};\n\n    const apiKey \u003d _getApiKey_();\n    if (!apiKey) {\n      throw new Error(\"API Key non configur√©e - voir SETTINGS.mcp_api_key\");\n    }\n\n    const baseUrl \u003d _getProxyUrl_();\n    const url \u003d baseUrl + endpoint;\n\n    const httpOptions \u003d {\n      method: method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-API-Key\": apiKey\n      },\n      muteHttpExceptions: true\n    };\n\n    if (options.payload !\u003d\u003d undefined \u0026\u0026 options.payload !\u003d\u003d null) {\n      httpOptions.payload \u003d JSON.stringify(options.payload);\n    }\n\n    let lastError \u003d null;\n\n    for (let retry \u003d 0; retry \u003c MAX_RETRIES; retry++) {\n      try {\n        const response \u003d UrlFetchApp.fetch(url, httpOptions);\n        const code \u003d response.getResponseCode();\n        const text \u003d response.getContentText();\n\n        if (code \u003e\u003d 200 \u0026\u0026 code \u003c 300) {\n          try {\n            return JSON.parse(text);\n          } catch (e) {\n            return { ok: true, raw: text };\n          }\n        }\n\n        lastError \u003d new Error(\"HTTP \" + code + \": \" + text);\n\n        // Retry uniquement sur 5xx\n        if (code \u003e\u003d 500 \u0026\u0026 retry \u003c MAX_RETRIES - 1) {\n          Utilities.sleep(1000 * (retry + 1));\n          continue;\n        }\n        throw lastError;\n\n      } catch (e) {\n        lastError \u003d e;\n        if (retry \u003c MAX_RETRIES - 1) {\n          Utilities.sleep(1000 * (retry + 1));\n          continue;\n        }\n      }\n    }\n\n    throw lastError || new Error(\"Request failed after retries\");\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // DRIVE ENDPOINTS\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function driveListTree(folderId, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      folder_id: folderId,\n      max_depth: (options.max_depth !\u003d\u003d undefined ? options.max_depth : 2),\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 100),\n      include_trashed: (options.include_trashed !\u003d\u003d undefined ? options.include_trashed : false),\n      page_token: options.page_token\n    });\n    return _makeRequest_(\"get\", \"/drive/tree\" + qs, {});\n  }\n\n  function driveFileMetadata(fileId) {\n    return _makeRequest_(\"get\", \"/drive/file/\" + encodeURIComponent(fileId) + \"/metadata\", {});\n  }\n\n  function driveSearch(query, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      query: query,\n      folder_id: options.folder_id,\n      mime_type: options.mime_type,\n      modified_after: options.modified_after,\n      page_token: options.page_token,\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 50)\n    });\n    return _makeRequest_(\"get\", \"/drive/search\" + qs, {});\n  }\n\n  function driveReadText(fileId, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      file_id: fileId,\n      max_size: (options.max_size !\u003d\u003d undefined ? options.max_size : 1048576)\n    });\n    return _makeRequest_(\"get\", \"/drive/file/\" + encodeURIComponent(fileId) + \"/text\" + qs, {});\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // APPS SCRIPT ENDPOINTS\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function appsScriptDeployments(scriptId, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 20),\n      page_token: options.page_token\n    });\n    return _makeRequest_(\"get\", \"/apps-script/project/\" + encodeURIComponent(scriptId) + \"/deployments\" + qs, {});\n  }\n\n  function appsScriptStructure(scriptId) {\n    return _makeRequest_(\"get\", \"/apps-script/project/\" + encodeURIComponent(scriptId) + \"/structure\", {});\n  }\n\n  function appsScriptFileMetadata(scriptId, fileName) {\n    const qs \u003d _toQueryString_({ file_name: fileName });\n    return _makeRequest_(\"get\", \"/apps-script/project/\" + encodeURIComponent(scriptId) + \"/file-metadata\" + qs, {});\n  }\n\n  function appsScriptLogs(scriptId, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 100),\n      start_time: options.start_time,\n      end_time: options.end_time,\n      page_token: options.page_token\n    });\n    return _makeRequest_(\"get\", \"/apps-script/project/\" + encodeURIComponent(scriptId) + \"/logs\" + qs, {});\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // CLOUD RUN ENDPOINTS\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function cloudRunServiceStatus(serviceName, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      region: options.region\n    });\n    return _makeRequest_(\"get\", \"/cloud-run/service/\" + encodeURIComponent(serviceName) + \"/status\" + qs, {});\n  }\n\n  function cloudRunJobsStatus(jobName, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      region: options.region\n    });\n    return _makeRequest_(\"get\", \"/cloud-run/job/\" + encodeURIComponent(jobName) + \"/status\" + qs, {});\n  }\n\n  function cloudLoggingQuery(resourceType, resourceLabels, options) {\n    options \u003d options || {};\n\n    const payload \u003d {\n      resource_type: resourceType,\n      resource_labels: resourceLabels,\n      filter: (options.filter !\u003d\u003d undefined ? options.filter : \"severity\u003e\u003dINFO\"),\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 100)\n    };\n\n    if (options.start_time) payload.start_time \u003d options.start_time;\n    if (options.end_time) payload.end_time \u003d options.end_time;\n    if (options.page_token) payload.page_token \u003d options.page_token;\n\n    return _makeRequest_(\"post\", \"/cloud-logging/query\", { payload: payload });\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // SECRET MANAGER ENDPOINTS (GOVERNED)\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function secretsList(options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      project_id: options.project_id,\n      filter: options.filter,\n      page_token: options.page_token,\n      limit: (options.limit !\u003d\u003d undefined ? options.limit : 50)\n    });\n    return _makeRequest_(\"get\", \"/secrets/list\" + qs, {});\n  }\n\n  function secretGetReference(secretId, options) {\n    options \u003d options || {};\n    const qs \u003d _toQueryString_({\n      project_id: options.project_id,\n      version: (options.version !\u003d\u003d undefined ? options.version : \"latest\")\n    });\n    return _makeRequest_(\"get\", \"/secrets/\" + encodeURIComponent(secretId) + \"/reference\" + qs, {});\n  }\n\n  function secretCreate(secretId, value, options) {\n    options \u003d options || {};\n    const payload \u003d {\n      project_id: options.project_id,\n      secret_id: secretId,\n      value: value,\n      labels: options.labels || {},\n      replication: (options.replication !\u003d\u003d undefined ? options.replication : \"automatic\"),\n      dry_run: (options.dry_run !\u003d\u003d false)\n    };\n    return _makeRequest_(\"post\", \"/secrets/create\", { payload: payload });\n  }\n\n  function secretRotate(secretId, newValue, options) {\n    options \u003d options || {};\n    const payload \u003d {\n      project_id: options.project_id,\n      secret_id: secretId,\n      new_value: newValue,\n      disable_previous_version: (options.disable_previous_version !\u003d\u003d undefined ? options.disable_previous_version : false),\n      dry_run: (options.dry_run !\u003d\u003d false)\n    };\n    return _makeRequest_(\"post\", \"/secrets/\" + encodeURIComponent(secretId) + \"/rotate\", { payload: payload });\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // WEB ACCESS ENDPOINTS\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function webSearch(query, options) {\n    options \u003d options || {};\n    const payload \u003d {\n      query: query,\n      max_results: (options.max_results !\u003d\u003d undefined ? options.max_results : 10),\n      allowed_domains: (options.allowed_domains !\u003d\u003d undefined ? options.allowed_domains : [])\n    };\n    return _makeRequest_(\"post\", \"/web/search\", { payload: payload });\n  }\n\n  function webFetch(url, options) {\n    options \u003d options || {};\n    const payload \u003d {\n      url: url,\n      method: (options.method !\u003d\u003d undefined ? options.method : \"GET\"),\n      headers: (options.headers !\u003d\u003d undefined ? options.headers : {}),\n      max_size: (options.max_size !\u003d\u003d undefined ? options.max_size : 1048576)\n    };\n    return _makeRequest_(\"post\", \"/web/fetch\", { payload: payload });\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // TERMINAL RUNNER ENDPOINT (GOVERNED)\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  function terminalRun(command, options) {\n    options \u003d options || {};\n    const payload \u003d {\n      command: command,\n      mode: (options.mode !\u003d\u003d undefined ? options.mode : \"READ_ONLY\"),\n      timeout_seconds: (options.timeout_seconds !\u003d\u003d undefined ? options.timeout_seconds : 30),\n      dry_run: (options.dry_run !\u003d\u003d false)\n    };\n    return _makeRequest_(\"post\", \"/terminal/run\", { payload: payload });\n  }\n\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n  // PUBLIC API\n  // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n  return {\n    // Drive\n    driveListTree: driveListTree,\n    driveFileMetadata: driveFileMetadata,\n    driveSearch: driveSearch,\n    driveReadText: driveReadText,\n\n    // Apps Script\n    appsScriptDeployments: appsScriptDeployments,\n    appsScriptStructure: appsScriptStructure,\n    appsScriptFileMetadata: appsScriptFileMetadata,\n    appsScriptLogs: appsScriptLogs,\n\n    // Cloud Run\n    cloudRunServiceStatus: cloudRunServiceStatus,\n    cloudRunJobsStatus: cloudRunJobsStatus,\n    cloudLoggingQuery: cloudLoggingQuery,\n\n    // Secrets (GOVERNED)\n    secretsList: secretsList,\n    secretGetReference: secretGetReference,\n    secretCreate: secretCreate,\n    secretRotate: secretRotate,\n\n    // Web\n    webSearch: webSearch,\n    webFetch: webFetch,\n\n    // Terminal (GOVERNED)\n    terminalRun: terminalRun\n  };\n\n})();"},{"id":"fee7b3a8-ab67-4409-a19d-2e187a597f64","name":"G99_README","type":"server_js","source":"// File: /CODE/99_README.gs\n\nfunction IAPF_initHub() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const res \u003d IAPF_initHub_({ quiet: false });\n  if (!res.ok) {\n    ui.alert(\"Init HUB: ERREUR\", res.error || \"Unknown error\", ui.ButtonSet.OK);\n    return;\n  }\n  ui.alert(\"Init HUB: OK\", \"Onglets/headers valid√©s. (Voir LOGS)\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_installDailyTrigger() {\n  const ui \u003d SpreadsheetApp.getUi();\n  const res \u003d IAPF_installDailyTrigger_();\n  if (!res.ok) {\n    ui.alert(\"Trigger daily: ERREUR\", res.error || \"Unknown error\", ui.ButtonSet.OK);\n    return;\n  }\n  ui.alert(\"Trigger daily: OK\", \"D√©clencheur daily 06:00 configur√©.\", ui.ButtonSet.OK);\n}\n\nfunction IAPF_installDailyTrigger_() {\n  try {\n    const fnName \u003d \"IAPF_generateSnapshot_\";\n    const triggers \u003d ScriptApp.getProjectTriggers();\n    triggers.forEach((t) \u003d\u003e {\n      if (t.getHandlerFunction \u0026\u0026 t.getHandlerFunction() \u003d\u003d\u003d fnName) {\n        ScriptApp.deleteTrigger(t);\n      }\n    });\n\n    ScriptApp.newTrigger(fnName)\n      .timeBased()\n      .everyDays(1)\n      .atHour(6)\n      .create();\n\n    IAPF_log_(\"INFO\", \"TRIGGER_DAILY_SET\", \"Daily trigger set at 06:00\", {});\n    return { ok: true };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"TRIGGER_DAILY_FAIL\", String(err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_initHub_(opts) {\n  try {\n    const ss \u003d IAPF_getActiveSS_();\n    IAPF_ensureSheet_(ss, IAPF.SETTINGS_SHEET, [\"key\", \"value\", \"notes\"]);\n    IAPF_ensureSheet_(ss, IAPF.MEMORY_LOG_SHEET, [\"ts_iso\", \"type\", \"title\", \"details\", \"author\", \"source\", \"tags\"]);\n    IAPF_ensureSheet_(ss, IAPF.SNAPSHOT_SHEET, [\"generated_ts_iso\", \"snapshot_text\"]);\n    IAPF_ensureSheet_(ss, IAPF.ERRORS_SHEET, [\"code\", \"title\", \"status\", \"last_seen_ts_iso\", \"details\"]);\n    IAPF_ensureSheet_(ss, IAPF.LOGS_SHEET, [\"ts_iso\", \"level\", \"event\", \"message\", \"data_json\"]);\n\n    IAPF_seedErrorsIfEmpty_();\n\n    if (!opts || !opts.quiet) {\n      IAPF_log_(\"INFO\", \"INIT_HUB_OK\", \"Hub initialized/validated\", {});\n    }\n    return { ok: true };\n  } catch (err) {\n    IAPF_log_(\"ERROR\", \"INIT_HUB_FAIL\", String(err \u0026\u0026 err.stack ? err.stack : err), {});\n    return { ok: false, error: String(err) };\n  }\n}\n\nfunction IAPF_ensureSheet_(ss, name, headers) {\n  let sh \u003d ss.getSheetByName(name);\n  if (!sh) sh \u003d ss.insertSheet(name);\n\n  const firstRow \u003d sh.getRange(1, 1, 1, headers.length).getValues()[0];\n  let needsHeader \u003d false;\n  for (let i \u003d 0; i \u003c headers.length; i++) {\n    if (String(firstRow[i] || \"\").trim() !\u003d\u003d headers[i]) {\n      needsHeader \u003d true;\n      break;\n    }\n  }\n  if (needsHeader) {\n    sh.getRange(1, 1, 1, headers.length).setValues([headers]);\n    sh.getRange(1, 1, 1, headers.length).setFontWeight(\"bold\");\n  }\n}\n\nfunction IAPF_seedErrorsIfEmpty_() {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.ERRORS_SHEET);\n  const last \u003d sh.getLastRow();\n  if (last \u003e\u003d 2) return;\n\n  const seed \u003d [\n    [\"M3.7-001\", \"runner .cmd incomplet\", \"ACTIVE\", IAPF_nowIso_(), \"Ne pas produire de runner incomplet.\"],\n    [\"M3.7-002\", \"ParserError accents/encodage\", \"ACTIVE\", IAPF_nowIso_(), \"Forcer UTF-8, √©viter pi√®ges d‚Äôaccents.\"],\n    [\"M3.7-003\", \"Set-StrictMode avant param\", \"ACTIVE\", IAPF_nowIso_(), \"Si PowerShell, ordre correct.\"],\n    [\"M3.7-005\", \"New-Item -LiteralPath non support√©\", \"ACTIVE\", IAPF_nowIso_(), \"Remplacer par -Path.\"],\n    [\"M3.8-001\", \"$events.Count scalaire\", \"ACTIVE\", IAPF_nowIso_(), \"Utiliser @($events) en PowerShell.\"],\n    [\"M3.8-002\", \"ArgumentException types arguments\", \"ACTIVE\", IAPF_nowIso_(), \"Normaliser chemins + logs d√©taill√©s.\"]\n  ];\n  sh.getRange(2, 1, seed.length, 5).setValues(seed);\n}\n\nfunction IAPF_getConfig_(key) {\n  const fromProps \u003d IAPF_getScriptProp_(key);\n  if (fromProps) return fromProps;\n\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.SETTINGS_SHEET);\n  const last \u003d sh.getLastRow();\n  if (last \u003c 2) return \"\";\n\n  const data \u003d sh.getRange(2, 1, last - 1, 3).getValues();\n  for (let i \u003d 0; i \u003c data.length; i++) {\n    const k \u003d String(data[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) return String(data[i][1] || \"\").trim();\n  }\n  return \"\";\n}\n\nfunction IAPF_setConfig_(key, value) {\n  IAPF_setScriptProp_(key, value);\n\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.SETTINGS_SHEET);\n  const last \u003d sh.getLastRow();\n  const v \u003d String(value || \"\").trim();\n\n  if (last \u003c 2) {\n    sh.appendRow([key, v, \"\"]);\n    return;\n  }\n\n  const data \u003d sh.getRange(2, 1, last - 1, 3).getValues();\n  for (let i \u003d 0; i \u003c data.length; i++) {\n    const k \u003d String(data[i][0] || \"\").trim();\n    if (k \u003d\u003d\u003d key) {\n      sh.getRange(i + 2, 2).setValue(v);\n      return;\n    }\n  }\n  sh.appendRow([key, v, \"\"]);\n}\n\nfunction IAPF_readLastMemoryEntries_(n) {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.MEMORY_LOG_SHEET);\n  const last \u003d sh.getLastRow();\n  if (last \u003c 2) return [];\n\n  const take \u003d Math.min(n || 30, last - 1);\n  const start \u003d last - take + 1;\n  const vals \u003d sh.getRange(start, 1, take, 7).getValues();\n\n  const items \u003d vals.map((r) \u003d\u003e ({\n    ts_iso: String(r[0] || \"\"),\n    type: String(r[1] || \"\"),\n    title: String(r[2] || \"\"),\n    details: String(r[3] || \"\"),\n    author: String(r[4] || \"\"),\n    source: String(r[5] || \"\"),\n    tags: String(r[6] || \"\")\n  }));\n\n  items.sort((a, b) \u003d\u003e (a.ts_iso \u003c b.ts_iso ? 1 : -1));\n  return items;\n}\n\nfunction IAPF_readErrorsActive_() {\n  const ss \u003d IAPF_getActiveSS_();\n  const sh \u003d ss.getSheetByName(IAPF.ERRORS_SHEET);\n  const last \u003d sh.getLastRow();\n  if (last \u003c 2) return [];\n\n  const vals \u003d sh.getRange(2, 1, last - 1, 5).getValues();\n  const items \u003d vals.map((r) \u003d\u003e ({\n    code: String(r[0] || \"\"),\n    title: String(r[1] || \"\"),\n    status: String(r[2] || \"\"),\n    last_seen_ts_iso: String(r[3] || \"\"),\n    details: String(r[4] || \"\")\n  }));\n\n  const active \u003d items.filter(x \u003d\u003e String(x.status || \"\").toUpperCase() \u003d\u003d\u003d \"ACTIVE\");\n  return active;\n}\n\nfunction IAPF_getRoadmapHint_() {\n  const id \u003d IAPF_getConfig_(\"roadmap_file_id\");\n  if (!id) return \"\";\n  try {\n    const f \u003d DriveApp.getFileById(id);\n    return `${f.getName()} (${id})`;\n  } catch (e) {\n    IAPF_log_(\"WARN\", \"ROADMAP_ID_INVALID\", \"roadmap_file_id invalid or no access\", { id });\n    return \"\";\n  }\n}\n"}]}